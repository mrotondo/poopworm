<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta http-equiv="Content-Style-Type" content="text/css">
<title></title>
<meta name="Generator" content="Cocoa HTML Writer">
<meta name="CocoaVersion" content="824.42">
<style type="text/css">
p.p1 {margin: 0.0px 0.0px 0.0px 0.0px; font: 9.0px Monaco; color: #a71e12}
p.p2 {margin: 0.0px 0.0px 0.0px 0.0px; font: 9.0px Monaco; min-height: 12.0px}
p.p3 {margin: 0.0px 0.0px 0.0px 0.0px; font: 9.0px Monaco}
span.s1 {color: #0019b7}
span.s2 {color: #000000}
span.s3 {color: #a71e12}
span.s4 {color: #606060}
span.s5 {color: #326f17}
span.Apple-tab-span {white-space:pre}
</style>
</head>
<body>
<p class="p1">// The J programming language is a successor of APL. &lt;http://www.jsoftware.com&gt;</p>
<p class="p1">// These languages are made for processing arrays of data and are able to express</p>
<p class="p1">// complex notions of iteration implicitly.</p>
<p class="p1">// The following are some concepts borrowed from or inspired by J.</p>
<p class="p1">// Thinking about multidimensional arrays can be both mind bending and mind expanding.</p>
<p class="p1">// It may take some effort to grasp what is happening in these examples.</p>
<p class="p2"><br></p>
<p class="p1">// iota fills an array with a counter</p>
<p class="p3">z = <span class="s1">Array</span>.iota(2, 3, 3);</p>
<p class="p1"><span class="s2">z.rank; </span>// 3 dimensions</p>
<p class="p1"><span class="s2">z.shape; </span>// gives the sizes of the dimensions</p>
<p class="p1"><span class="s2">z = z.reshape(3, 2, 3); </span>// reshape changes the dimensions of an array</p>
<p class="p1"><span class="s2">z.rank; </span>// 3 dimensions</p>
<p class="p3">z.shape;</p>
<p class="p2"><br></p>
<p class="p1">// fill a 2D array</p>
<p class="p3"><span class="s1">Array</span>.fill2D(3,3,{1.0.rand.round(0.01)});</p>
<p class="p2"><br></p>
<p class="p3"><span class="s1">Array</span>.fill2D(2,3,{<span class="s1">|i,j|</span> i@j});</p>
<p class="p2"><br></p>
<p class="p1">// fill a 3D array</p>
<p class="p3"><span class="s1">Array</span>.fill3D(2,2,2,{1.0.rand.round(0.01)});</p>
<p class="p2"><br></p>
<p class="p3"><span class="s1">Array</span>.fill3D(2,2,2,{<span class="s1">|i,j,k|</span> `[i,j,k]});</p>
<p class="p2"><br></p>
<p class="p2"><br></p>
<p class="p1">// using dup to create arrays</p>
<p class="p3">(1..4) dup: 3;</p>
<p class="p3">100.rand dup: 10;</p>
<p class="p3">{100.rand} dup: 10;</p>
<p class="p3">{100.rand} dup: 3 dup: 4;</p>
<p class="p3">{{100.rand} dup: 3} dup: 4;</p>
<p class="p3">{<span class="s1">|i|</span> i.squared} dup: 10;</p>
<p class="p3">{<span class="s1">|i|</span> i.nthPrime} dup: 10;</p>
<p class="p2"><br></p>
<p class="p1">// ! is an abbreviation of dup</p>
<p class="p3">(1..4) ! 3;</p>
<p class="p3">100.rand ! 10;</p>
<p class="p3">{100.rand} ! 10;</p>
<p class="p3">{100.rand} ! 3 ! 4;</p>
<p class="p3">{{100.rand} ! 3} ! 4;</p>
<p class="p3">{<span class="s1">|i|</span> i.squared} ! 10;</p>
<p class="p3">{<span class="s1">|i|</span> i.nthPrime} ! 10;</p>
<p class="p2"><br></p>
<p class="p1">// other ways to do the same thing:</p>
<p class="p1"><span class="Apple-tab-span">	</span>// partial application</p>
<p class="p3"><span class="s1">_</span>.squared ! 10;</p>
<p class="p3"><span class="s1">_</span>.nthPrime ! 10;</p>
<p class="p2"><br></p>
<p class="p1"><span class="Apple-tab-span">	</span>// operating on a list</p>
<p class="p3">(0..9).squared;</p>
<p class="p3">(0..9).nthPrime;</p>
<p class="p2"><br></p>
<p class="p1">// operator adverbs</p>
<p class="p1">// Adverbs are a third argument passed to binary operators that modifies how they iterate over</p>
<p class="p1">// SequenceableCollections or Streams.</p>
<p class="p1">// see the Adverbs help file</p>
<p class="p3">[10, 20, 30, 40, 50] + [1, 2, 3]; <span class="s3">// normal</span></p>
<p class="p3">[10, 20, 30, 40, 50] +.f [1, 2, 3]; <span class="s3">// folded</span></p>
<p class="p3">[10, 20, 30, 40, 50] +.s [1, 2, 3]; <span class="s3">// shorter</span></p>
<p class="p3">[10, 20, 30, 40, 50] +.x [1, 2, 3]; <span class="s3">// cross</span></p>
<p class="p3">[10, 20, 30, 40, 50] +.t [1, 2, 3]; <span class="s3">// table</span></p>
<p class="p2"><br></p>
<p class="p1">// operator depth.</p>
<p class="p1">// J has a concept called verb rank, which is probably too complex to understand and implement<span class="Apple-converted-space"> </span></p>
<p class="p1">// in SC, but operator depth is similar and simpler.</p>
<p class="p1">// A binary operator can be given a depth at which to operate</p>
<p class="p1">// negative depths iterate the opposite operand.</p>
<p class="p1">// These are better understood by example.</p>
<p class="p1">// It is not currently possible to combine adverb and depth.</p>
<p class="p3">z = <span class="s1">Array</span>.iota(3,3);</p>
<p class="p3">y = [100, 200, 300];</p>
<p class="p3">z + y;</p>
<p class="p1"><span class="s2">z +.0 y; </span>// same as the above. y added to each row of z</p>
<p class="p1"><span class="s2">z +.1 y; </span>// y added to each column of z</p>
<p class="p1"><span class="s2">z +.2 y; </span>// y added to each element of z</p>
<p class="p1"><span class="s2">z +.-1 y; </span>// z added to each element of y</p>
<p class="p2"><br></p>
<p class="p1">// deepCollect operates a function at different dimensions or depths in an array.</p>
<p class="p3">z = <span class="s1">Array</span>.iota(3, 2, 3);</p>
<p class="p3">f = {<span class="s1">|item|</span> item.reverse };</p>
<p class="p3">z.deepCollect(0, f);</p>
<p class="p3">z.deepCollect(1, f);</p>
<p class="p3">z.deepCollect(2, f);</p>
<p class="p2"><br></p>
<p class="p3">f = {<span class="s1">|item|</span> item.stutter };</p>
<p class="p3">z.deepCollect(0, f);</p>
<p class="p3">z.deepCollect(1, f);</p>
<p class="p3">z.deepCollect(2, f);</p>
<p class="p2"><br></p>
<p class="p1">// slice can get sections of multidimensional arrays.</p>
<p class="p1">// nil gets all the indices of a dimension</p>
<p class="p3">z = <span class="s1">Array</span>.iota(4,5);</p>
<p class="p3">z.slice(<span class="s1">nil</span>, (1..3));</p>
<p class="p3">z.slice(2, (1..3));</p>
<p class="p3">z.slice((2..3), (0..2));</p>
<p class="p3">z.slice((1..3), 3);</p>
<p class="p3">z.slice(2, 3);</p>
<p class="p2"><br></p>
<p class="p3">z = <span class="s1">Array</span>.iota(3,3,3);</p>
<p class="p3">z.slice([0,1],[1,2],[0,2]);</p>
<p class="p3">z.slice(<span class="s1">nil</span>,<span class="s1">nil</span>,[0,2]);</p>
<p class="p3">z.slice(1);</p>
<p class="p3">z.slice(<span class="s1">nil</span>,1);</p>
<p class="p3">z.slice(<span class="s1">nil</span>,<span class="s1">nil</span>,1);</p>
<p class="p3">z.slice(<span class="s1">nil</span>,2,1);</p>
<p class="p3">z.slice(<span class="s1">nil</span>,1,(1..2));</p>
<p class="p3">z.slice(1,[0,1]);</p>
<p class="p3">z.flop;</p>
<p class="p2"><br></p>
<p class="p1">// sorting order</p>
<p class="p2"><br></p>
<p class="p1"><span class="s2">z = {100.rand}.dup(10); </span>// generate a random array;</p>
<p class="p1">// order returns an array of indices representing what would be the sorted order of the array.</p>
<p class="p3">o = z.order;<span class="Apple-converted-space"> </span></p>
<p class="p1"><span class="s2">y = z[o]; </span>// using the order as an index returns the sorted array</p>
<p class="p2"><br></p>
<p class="p1">// calling order on the order returns an array of indices that returns the sorted array to the<span class="Apple-converted-space"> </span></p>
<p class="p1">// original scrambled order</p>
<p class="p3">p = o.order;<span class="Apple-converted-space"> </span></p>
<p class="p3">x = y[p];</p>
<p class="p2"><br></p>
<p class="p1">// bubbling wraps an item in an array of one element. it takes the depth and levels as arguments.</p>
<p class="p3">z = <span class="s1">Array</span>.iota(4,4);</p>
<p class="p3">z.bubble;</p>
<p class="p3">z.bubble(1);</p>
<p class="p3">z.bubble(2);</p>
<p class="p3">z.bubble(0,2);</p>
<p class="p3">z.bubble(1,2);</p>
<p class="p3">z.bubble(2,2);</p>
<p class="p1">// similarly, unbubble unwraps an Array if it contains a single element.</p>
<p class="p3">5.unbubble;</p>
<p class="p3">[5].unbubble;</p>
<p class="p3">[[5]].unbubble;</p>
<p class="p3">[[5]].unbubble(0,2);</p>
<p class="p3">[4,5].unbubble;</p>
<p class="p3">[[4],[5]].unbubble;</p>
<p class="p3">[[4],[5]].unbubble(1);</p>
<p class="p3">z.bubble.unbubble;</p>
<p class="p3">z.bubble(1).unbubble(1);</p>
<p class="p3">z.bubble(2).unbubble(2);</p>
<p class="p2"><br></p>
<p class="p1">// laminating with the +++ operator</p>
<p class="p1">// the +++ operator takes each item from the second list and appends it to the corresponding item</p>
<p class="p1">// in the first list. If the second list is shorter, it wraps.</p>
<p class="p3">z = <span class="s1">Array</span>.iota(5,2);</p>
<p class="p3">z +++ [77,88,99];</p>
<p class="p3">z +++ [[77,88,99]];</p>
<p class="p3">z +++ [[[77,88,99]]];</p>
<p class="p3">z +++ [ [[77]],[[88]],[[99]] ];</p>
<p class="p1">// same as:</p>
<p class="p3">z +++ [77,88,99].bubble;</p>
<p class="p3">z +++ [77,88,99].bubble(0,2);</p>
<p class="p3">z +++ [77,88,99].bubble(1,2);</p>
<p class="p2"><br></p>
<p class="p3">z +++ [11,22,33].pyramidg;</p>
<p class="p3">z +++ [11,22,33].pyramidg.bubble;</p>
<p class="p3">z +++ [[11,22,33].pyramidg];</p>
<p class="p3">z +++ [[[11,22,33].pyramidg]];</p>
<p class="p2"><br></p>
<p class="p2"><br></p>
<p class="p3">(</p>
<p class="p3">z = (1..4);</p>
<p class="p3">10.do {<span class="s1">|i|</span><span class="Apple-converted-space"> </span></p>
<p class="p3"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>z.pyramid(i+1).postln;</p>
<p class="p3"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>z.pyramidg(i+1).postln;</p>
<p class="p3"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="s4">""</span>.postln;</p>
<p class="p3">};</p>
<p class="p3">)</p>
<p class="p2"><br></p>
<p class="p1">// reshapeLike allows you to make one nested array be restructured in the same manner as another.</p>
<p class="p2"><br></p>
<p class="p3">a = [[10,20],[30, 40, 50], 60, 70, [80, 90]];</p>
<p class="p3">b = [[1, 2, [3, 4], [[5], 6], 7], 8, [[9]]];</p>
<p class="p3">a.reshapeLike(b);</p>
<p class="p3">b.reshapeLike(a);</p>
<p class="p2"><br></p>
<p class="p1">// If the lengths are different, the default behaviour is to wrap:</p>
<p class="p2"><br></p>
<p class="p3">a = [[10,20],[30, 40, 50]];</p>
<p class="p3">b = [[1, 2, [3, 4], [[5], 6], 7], 8, [[9]]];</p>
<p class="p3">a.reshapeLike(b);</p>
<p class="p2"><br></p>
<p class="p1">// but you can specify other index operators:</p>
<p class="p2"><br></p>
<p class="p3">a.reshapeLike(b, <span class="s5">\foldAt</span>);</p>
<p class="p2"><br></p>
<p class="p3">a.reshapeLike(b, <span class="s5">\clipAt</span>);</p>
<p class="p2"><br></p>
<p class="p3">a.reshapeLike(b, <span class="s5">\at</span>);</p>
<p class="p2"><br></p>
<p class="p1">// allTuples will generate all combinations of the sub arrays</p>
<p class="p3">[[1, 2, 3], [4, 5], 6].allTuples;</p>
<p class="p3">[[1, 2, 3], [4, 5, 6, 7], [8, 9]].allTuples;</p>
<p class="p2"><br></p>
<p class="p2"><br></p>
<p class="p2"><br></p>
</body>
</html>
