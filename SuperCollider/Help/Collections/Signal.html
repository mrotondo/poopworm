<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta http-equiv="Content-Style-Type" content="text/css">
<title></title>
<meta name="Generator" content="Cocoa HTML Writer">
<meta name="CocoaVersion" content="824.48">
<style type="text/css">
p.p1 {margin: 0.0px 0.0px 0.0px 0.0px; font: 12.0px Helvetica}
p.p2 {margin: 0.0px 0.0px 0.0px 0.0px; font: 18.0px Helvetica; min-height: 22.0px}
p.p3 {margin: 0.0px 0.0px 0.0px 0.0px; font: 12.0px Helvetica; color: #0021e7}
p.p4 {margin: 0.0px 0.0px 0.0px 0.0px; font: 12.0px Helvetica; min-height: 14.0px}
p.p5 {margin: 0.0px 0.0px 0.0px 0.0px; font: 14.0px Helvetica}
p.p6 {margin: 0.0px 0.0px 0.0px 0.0px; font: 9.0px Monaco; min-height: 12.0px}
p.p7 {margin: 0.0px 0.0px 0.0px 0.0px; font: 9.0px Monaco}
p.p8 {margin: 0.0px 0.0px 0.0px 0.0px; font: 12.0px Monaco; min-height: 16.0px}
p.p9 {margin: 0.0px 0.0px 0.0px 0.0px; font: 9.0px Monaco; color: #9d1c12}
p.p10 {margin: 0.0px 0.0px 0.0px 0.0px; font: 14.0px Helvetica; min-height: 17.0px}
span.s1 {font: 18.0px Helvetica}
span.s2 {color: #000000}
span.s3 {color: #0026b4}
span.s4 {color: #002fe0}
span.s5 {color: #0021e7}
span.s6 {color: #606060}
span.s7 {color: #9d1c12}
span.Apple-tab-span {white-space:pre}
</style>
</head>
<body>
<p class="p1"><span class="s1"><b>Signal<span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span></b></span><b>sampled audio buffer</b></p>
<p class="p2"><br></p>
<p class="p3"><span class="s2"><b>Inherits from: </b><a href="../Core/Object.html"><b>Object</b></a><b> : </b><a href="Collection.html"><b>Collection</b></a></span><span class="s3"><b> :</b></span><span class="s2"><b> </b><a href="SequenceableCollection.html"><b>SequenceableCollection</b></a></span><span class="s3"><b> : </b><a href="ArrayedCollection.html"><span class="s4"><b>ArrayedCollection</b></span></a> : <a href="RawArray.html"><span class="s5"><b>RawArray</b></span></a></span><span class="s2"> : <a href="FloatArray.html"><span class="s3"><b>FloatArray</b></span></a></span></p>
<p class="p4"><br></p>
<p class="p1">A Signal is a FloatArray that represents a sampled function of time buffer.<span class="Apple-converted-space"> </span></p>
<p class="p1">Signals support math operations.</p>
<p class="p4"><br></p>
<p class="p1">See also: <a href="Wavetable.html"><span class="s3">Wavetable</span></a></p>
<p class="p4"><br></p>
<p class="p4"><br></p>
<p class="p5"><b><i>Creation</i></b></p>
<p class="p4"><br></p>
<p class="p1"><b>*sineFill(size, amplitudes, phases)</b></p>
<p class="p4"><br></p>
<p class="p1">Fill a Signal of the given size with a sum of sines at the given amplitudes and phases.</p>
<p class="p1">The Signal will be normalized.</p>
<p class="p1"><b>size</b> - the number of samples in the Signal.</p>
<p class="p1"><b>amplitudes</b> - an Array of amplitudes for each harmonic beginning with the fundamental.</p>
<p class="p1"><b>phases</b> - an Array of phases in radians for each harmonic beginning with the fundamental.</p>
<p class="p6"><br></p>
<p class="p7"><span class="s3">Signal</span>.sineFill(1000, 1.0/[1, 2, 3, 4, 5, 6]).plot;</p>
<p class="p8"><br></p>
<p class="p4"><br></p>
<p class="p1"><b>*chebyFill(size, amplitudes, phases)</b></p>
<p class="p4"><br></p>
<p class="p1">Fill a Signal of the given size with a sum of Chebyshev polynomials at the given amplitudes.</p>
<p class="p1">For eventual use in waveshaping by the Shaper ugen; see Shaper helpfile and Buffer:cheby too.</p>
<p class="p1"><b>size</b> - the number of samples in the Signal.</p>
<p class="p1"><b>amplitudes</b> - an Array of amplitudes for each Chebyshev polynomial beginning with order 1.</p>
<p class="p6"><br></p>
<p class="p7"><span class="s3">Signal</span>.chebyFill(1000, [1]).plot;</p>
<p class="p6"><br></p>
<p class="p7"><span class="s3">Signal</span>.chebyFill(1000, [0, 1]).plot;</p>
<p class="p6"><br></p>
<p class="p7"><span class="s3">Signal</span>.chebyFill(1000, [0, 0, 1]).plot;</p>
<p class="p6"><br></p>
<p class="p7"><span class="s3">Signal</span>.chebyFill(1000, [0.3, -0.8, 1.1]).plot;</p>
<p class="p6"><br></p>
<p class="p6"><br></p>
<p class="p1"><b>*hanningWindow(size, pad)</b></p>
<p class="p4"><br></p>
<p class="p1">Fill a Signal of the given size with a Hanning window.</p>
<p class="p1"><b>size</b> - the number of samples in the Signal.</p>
<p class="p1"><b>pad</b> - the number of samples of the size that is zero padding.</p>
<p class="p6"><br></p>
<p class="p7"><span class="s3">Signal</span>.hanningWindow(1024).plot;</p>
<p class="p6"><br></p>
<p class="p7"><span class="s3">Signal</span>.hanningWindow(1024, 512).plot;</p>
<p class="p6"><br></p>
<p class="p6"><br></p>
<p class="p1"><b>*hammingWindow(size)</b></p>
<p class="p4"><br></p>
<p class="p1">Fill a Signal of the given size with a Hamming window.</p>
<p class="p1"><b>size</b> - the number of samples in the Signal.</p>
<p class="p1"><b>pad</b> - the number of samples of the size that is zero padding.</p>
<p class="p6"><br></p>
<p class="p7"><span class="s3">Signal</span>.hammingWindow(1024).plot;</p>
<p class="p6"><br></p>
<p class="p7"><span class="s3">Signal</span>.hammingWindow(1024, 512).plot;</p>
<p class="p6"><br></p>
<p class="p6"><br></p>
<p class="p1"><b>*welchWindow(size)</b></p>
<p class="p4"><br></p>
<p class="p1">Fill a Signal of the given size with a Welch window.</p>
<p class="p1"><b>size</b> - the number of samples in the Signal.</p>
<p class="p1"><b>pad</b> - the number of samples of the size that is zero padding.</p>
<p class="p6"><br></p>
<p class="p7"><span class="s3">Signal</span>.welchWindow(1024).plot;</p>
<p class="p6"><br></p>
<p class="p7"><span class="s3">Signal</span>.welchWindow(1024, 512).plot;</p>
<p class="p6"><br></p>
<p class="p6"><br></p>
<p class="p1"><b>*rectWindow(size)</b></p>
<p class="p4"><br></p>
<p class="p1">Fill a Signal of the given size with a rectangular window.</p>
<p class="p1"><b>size</b> - the number of samples in the Signal.</p>
<p class="p1"><b>pad</b> - the number of samples of the size that is zero padding.</p>
<p class="p6"><br></p>
<p class="p7"><span class="s3">Signal</span>.rectWindow(1024).plot;</p>
<p class="p6"><br></p>
<p class="p7"><span class="s3">Signal</span>.rectWindow(1024, 512).plot;</p>
<p class="p6"><br></p>
<p class="p6"><br></p>
<p class="p6"><br></p>
<p class="p6"><br></p>
<p class="p6"><br></p>
<p class="p6"><br></p>
<p class="p5"><b><i>Instance Methods</i></b></p>
<p class="p4"><br></p>
<p class="p1"><b>plot(name, bounds)</b></p>
<p class="p4"><br></p>
<p class="p1">Plot the Signal in a window. The arguments are not required and if not given defaults will be used.</p>
<p class="p1"><b>name</b> - a String, the name of the window.</p>
<p class="p1"><b>bounds</b> - a Rect giving the bounds of the window.</p>
<p class="p6"><br></p>
<p class="p7"><span class="s3">Signal</span>.sineFill(512, [1]).plot;</p>
<p class="p6"><br></p>
<p class="p7"><span class="s3">Signal</span>.sineFill(512, [1]).plot(<span class="s6">"Signal 1"</span>, <span class="s3">Rect</span>(50, 50, 150, 450));</p>
<p class="p6"><br></p>
<p class="p6"><br></p>
<p class="p1"><b>play(loop, mul, numChannels, server)</b></p>
<p class="p4"><br></p>
<p class="p1">loads the signal into a buffer on the server and plays it.<span class="Apple-converted-space"> </span></p>
<p class="p1">returns the buffer so you can free it again.<span class="Apple-converted-space"> </span></p>
<p class="p1"><b>loop</b> - A Boolean whether to loop the entire signal or play it once. Default is to loop.</p>
<p class="p1"><b>mul</b> - volume at which to play it, 0.2 by default.</p>
<p class="p1"><b>numChannels</b> - if the signal is an interleaved multichannel file, number of channels, default is 1.</p>
<p class="p1"><b>server</b> - the server on which to load the signal into a buffer.<span class="Apple-converted-space"> </span></p>
<p class="p6"><br></p>
<p class="p7">b = <span class="s3">Signal</span>.sineFill(512, [1]).play(<span class="s3">true</span>, 0.2);</p>
<p class="p9"><span class="s2">b.free; <span class="Apple-tab-span">	</span></span>// free the buffer again.<span class="Apple-converted-space"> </span></p>
<p class="p6"><br></p>
<p class="p6"><br></p>
<p class="p1"><b>waveFill(function, start, end)</b></p>
<p class="p4"><br></p>
<p class="p1">Fill the Signal with a function evaluated over an interval.</p>
<p class="p1"><b>function</b> - a function that should calculate the value of a sample.</p>
<p class="p1">The function is called with two arguments.</p>
<p class="p1"><span class="Apple-tab-span">	</span><b>x</b> - the value along the interval.</p>
<p class="p1"><span class="Apple-tab-span">	</span><b>i</b> - the sample index.</p>
<p class="p1"><b>start</b> - the starting value of the interval</p>
<p class="p1"><b>end</b> - the ending value of the interval.</p>
<p class="p6"><span class="Apple-tab-span">	</span></p>
<p class="p7">(</p>
<p class="p7">s = <span class="s3">Signal</span>.newClear(512);</p>
<p class="p7">s.waveFill({ <span class="s3">arg</span> x, i; sin(x).max(0) }, 0, 3pi);</p>
<p class="p7">s.plot;</p>
<p class="p7">)</p>
<p class="p6"><br></p>
<p class="p1"><b>asWavetable</b></p>
<p class="p4"><br></p>
<p class="p1">Convert the Signal into a Wavetable.</p>
<p class="p6"><br></p>
<p class="p7"><span class="s3">Signal</span>.sineFill(512, [1]).asWavetable.plot;</p>
<p class="p6"><br></p>
<p class="p6"><br></p>
<p class="p1"><b>fill(val)</b></p>
<p class="p4"><br></p>
<p class="p1">Fill the Signal with a value.</p>
<p class="p6"><br></p>
<p class="p7"><span class="s3">Signal</span>.newClear(512).fill(0.2).plot;</p>
<p class="p6"><br></p>
<p class="p6"><br></p>
<p class="p1"><b>scale(scale)</b></p>
<p class="p4"><br></p>
<p class="p1">Scale the Signal by a factor <b>in place</b>.</p>
<p class="p6"><br></p>
<p class="p7">a = <span class="s3">Signal</span>[1, 2, 3, 4];</p>
<p class="p7">a.scale(0.5); a;</p>
<p class="p6"><br></p>
<p class="p6"><br></p>
<p class="p1"><b>offset(offset)</b></p>
<p class="p4"><br></p>
<p class="p1">Offset the Signal by a value <b>in place</b>.</p>
<p class="p6"><br></p>
<p class="p7">a = <span class="s3">Signal</span>[1, 2, 3, 4];</p>
<p class="p7">a.offset(0.5); a;</p>
<p class="p6"><br></p>
<p class="p6"><br></p>
<p class="p1"><b>peak</b></p>
<p class="p4"><br></p>
<p class="p1">Return the peak absolute value of a Signal.</p>
<p class="p6"><br></p>
<p class="p7"><span class="s3">Signal</span>[1, 2, -3, 2.5].peak;</p>
<p class="p6"><br></p>
<p class="p6"><br></p>
<p class="p1"><b>normalize</b></p>
<p class="p4"><br></p>
<p class="p1">Normalize the Signal <b>in place</b> such that the maximum absolute peak value is 1.</p>
<p class="p6"><br></p>
<p class="p7"><span class="s3">Signal</span>[1, 2, -4, 2.5].normalize;</p>
<p class="p7"><span class="s3">Signal</span>[1, 2, -4, 2.5].normalize(0, 1);<span class="Apple-tab-span">	</span><span class="s7">// normalize only a range</span></p>
<p class="p6"><br></p>
<p class="p6"><br></p>
<p class="p1"><b>normalizeTransfer</b></p>
<p class="p4"><br></p>
<p class="p1">Normalizes a transfer function so that the center value of the table is offset to zero</p>
<p class="p1">and the absolute peak value is 1. Transfer functions are meant to be used in the<span class="Apple-converted-space"> </span></p>
<p class="p1">Shaper ugen.</p>
<p class="p6"><br></p>
<p class="p7"><span class="s3">Signal</span>[1, 2, 3, 2.5, 1].normalizeTransfer;</p>
<p class="p6"><br></p>
<p class="p1"><b>invert</b></p>
<p class="p4"><br></p>
<p class="p1">Invert the Signal <b>in place</b>.</p>
<p class="p6"><br></p>
<p class="p7">a = <span class="s3">Signal</span>[1, 2, 3, 4];</p>
<p class="p7">a.invert(0.5); a;</p>
<p class="p6"><br></p>
<p class="p6"><br></p>
<p class="p1"><b>reverse(beginSamp, endSamp)</b></p>
<p class="p4"><br></p>
<p class="p1">Reverse a subrange of the Signal <b>in place</b>.</p>
<p class="p6"><br></p>
<p class="p7">a = <span class="s3">Signal</span>[1, 2, 3, 4];</p>
<p class="p7">a.reverse(1, 2); a;</p>
<p class="p6"><br></p>
<p class="p6"><br></p>
<p class="p1"><b>fade(beginSamp, endSamp, beginLevel, endLevel)</b></p>
<p class="p4"><br></p>
<p class="p1">Fade a subrange of the Signal <b>in place</b>.</p>
<p class="p6"><br></p>
<p class="p7">a = <span class="s3">Signal</span>.fill(10, 1);</p>
<p class="p7">a.fade(0, 3);<span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="s7">// fade in</span></p>
<p class="p7">a.fade(6, 9, 1, 0);<span class="Apple-tab-span">	</span><span class="s7">// fade out</span></p>
<p class="p6"><br></p>
<p class="p6"><br></p>
<p class="p1"><b>integral</b></p>
<p class="p4"><br></p>
<p class="p1">Return the integral of a signal.</p>
<p class="p6"><br></p>
<p class="p7"><span class="s3">Signal</span>[1, 2, 3, 4].integral;</p>
<p class="p6"><br></p>
<p class="p6"><br></p>
<p class="p1"><b>overDub(aSignal, index)</b></p>
<p class="p4"><br></p>
<p class="p1">Add a signal to myself starting at the index.</p>
<p class="p1">If the other signal is too long only the first part is overdubbed.</p>
<p class="p6"><br></p>
<p class="p7">a = <span class="s3">Signal</span>.fill(10, 100);</p>
<p class="p7">a.overDub(<span class="s3">Signal</span>[1, 2, 3, 4], 3);</p>
<p class="p6"><span class="Apple-tab-span">	</span></p>
<p class="p9"><span class="s2"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span></span>// run out of range</p>
<p class="p7">a = <span class="s3">Signal</span>.fill(10, 100);</p>
<p class="p7">a.overDub(<span class="s3">Signal</span>[1, 2, 3, 4], 8);<span class="Apple-tab-span">	</span></p>
<p class="p6"><br></p>
<p class="p7">a = <span class="s3">Signal</span>.fill(10, 100);</p>
<p class="p7">a.overDub(<span class="s3">Signal</span>[1, 2, 3, 4], -4);<span class="Apple-tab-span">	</span></p>
<p class="p6"><br></p>
<p class="p7">a = <span class="s3">Signal</span>.fill(10, 100);</p>
<p class="p7">a.overDub(<span class="s3">Signal</span>[1, 2, 3, 4], -1);<span class="Apple-tab-span">	</span></p>
<p class="p6"><br></p>
<p class="p7">a = <span class="s3">Signal</span>.fill(10, 100);</p>
<p class="p7">a.overDub(<span class="s3">Signal</span>[1, 2, 3, 4], -2);<span class="Apple-tab-span">	</span></p>
<p class="p6"><br></p>
<p class="p7">a = <span class="s3">Signal</span>.fill(4, 100);</p>
<p class="p7">a.overDub(<span class="s3">Signal</span>[1, 2, 3, 4, 5, 6, 7, 8], -2);<span class="Apple-tab-span">	</span></p>
<p class="p6"><br></p>
<p class="p6"><br></p>
<p class="p1"><b>overWrite(aSignal, index)</b></p>
<p class="p4"><br></p>
<p class="p1">Write a signal to myself starting at the index.</p>
<p class="p1">If the other signal is too long only the first part is overdubbed.</p>
<p class="p6"><br></p>
<p class="p7">a = <span class="s3">Signal</span>.fill(10, 100);</p>
<p class="p7">a.overWrite(<span class="s3">Signal</span>[1, 2, 3, 4], 3);</p>
<p class="p6"><span class="Apple-tab-span">	</span></p>
<p class="p9"><span class="s2"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span></span>// run out of range</p>
<p class="p7">a = <span class="s3">Signal</span>.fill(10, 100);</p>
<p class="p7">a.overWrite(<span class="s3">Signal</span>[1, 2, 3, 4], 8);<span class="Apple-tab-span">	</span></p>
<p class="p6"><br></p>
<p class="p7">a = <span class="s3">Signal</span>.fill(10, 100);</p>
<p class="p7">a.overWrite(<span class="s3">Signal</span>[1, 2, 3, 4], -4);<span class="Apple-tab-span">	</span></p>
<p class="p6"><br></p>
<p class="p7">a = <span class="s3">Signal</span>.fill(10, 100);</p>
<p class="p7">a.overWrite(<span class="s3">Signal</span>[1, 2, 3, 4], -1);<span class="Apple-tab-span">	</span></p>
<p class="p6"><br></p>
<p class="p7">a = <span class="s3">Signal</span>.fill(10, 100);</p>
<p class="p7">a.overWrite(<span class="s3">Signal</span>[1, 2, 3, 4], -2);<span class="Apple-tab-span">	</span></p>
<p class="p6"><br></p>
<p class="p7">a = <span class="s3">Signal</span>.fill(4, 100);</p>
<p class="p7">a.overWrite(<span class="s3">Signal</span>[1, 2, 3, 4, 5, 6, 7, 8], -2);<span class="Apple-tab-span">	</span></p>
<p class="p6"><br></p>
<p class="p6"><br></p>
<p class="p1"><b>blend(aSignal, blend)</b></p>
<p class="p4"><br></p>
<p class="p1">Blend two signals by some proportion.</p>
<p class="p6"><br></p>
<p class="p7"><span class="s3">Signal</span>[1, 2, 3, 4].blend(<span class="s3">Signal</span>[5, 5, 5, 0], 0);</p>
<p class="p7"><span class="s3">Signal</span>[1, 2, 3, 4].blend(<span class="s3">Signal</span>[5, 5, 5, 0], 0.2);</p>
<p class="p7"><span class="s3">Signal</span>[1, 2, 3, 4].blend(<span class="s3">Signal</span>[5, 5, 5, 0], 0.4);</p>
<p class="p7"><span class="s3">Signal</span>[1, 2, 3, 4].blend(<span class="s3">Signal</span>[5, 5, 5, 0], 1);</p>
<p class="p7"><span class="s3">Signal</span>[1, 2, 3, 4].blend(<span class="s3">Signal</span>[5, 5, 5, 0], 2);</p>
<p class="p6"><br></p>
<p class="p6"><br></p>
<p class="p6"><br></p>
<p class="p6"><br></p>
<p class="p5"><b><i>Fourier Transform:</i></b></p>
<p class="p10"><br></p>
<p class="p10"><br></p>
<p class="p1"><b>*fftCosTable(size)</b></p>
<p class="p4"><br></p>
<p class="p1">Fill a Signal with the cosine table needed by the FFT methods.</p>
<p class="p4"><br></p>
<p class="p7"><span class="s3">Signal</span>.fftCosTable(512).plot;</p>
<p class="p4"><br></p>
<p class="p4"><br></p>
<p class="p1"><b>fft(imag, cosTable)</b></p>
<p class="p4"><br></p>
<p class="p1">Perform an FFT on a real and imaginary signal <b>in place</b>.</p>
<p class="p4"><br></p>
<p class="p7">(</p>
<p class="p7"><span class="s3">var</span> size = 512, real, imag, cosTable, complex;<span class="Apple-converted-space"> </span></p>
<p class="p6"><br></p>
<p class="p7">real = <span class="s3">Signal</span>.newClear(size);<span class="Apple-converted-space"> </span></p>
<p class="p9"><span class="s2"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span></span>// some harmonics</p>
<p class="p7">real.sineFill2([[8], [13, 0.5], [21, 0.25], [55, 0.125, 0.5pi]]);</p>
<p class="p9"><span class="s2"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span></span>// add a little noise</p>
<p class="p7">real.overDub(<span class="s3">Signal</span>.fill(size, { 0.2.bilinrand }));</p>
<p class="p6"><br></p>
<p class="p7">imag = <span class="s3">Signal</span>.newClear(size);</p>
<p class="p7">cosTable = <span class="s3">Signal</span>.fftCosTable(size);</p>
<p class="p6"><br></p>
<p class="p7">complex = fft(real, imag, cosTable);<span class="Apple-converted-space"> </span></p>
<p class="p7">[real, imag, (complex.magnitude) / 100 ].flop.flat</p>
<p class="p7"><span class="Apple-tab-span">	</span>.plot(<span class="s6">"fft"</span>, <span class="s3">Rect</span>(0, 0, 512 + 8, 500), numChannels: 3);</p>
<p class="p7">)</p>
<p class="p8"><br></p>
<p class="p8"><br></p>
<p class="p1"><b>ifft(imag, cosTable)</b></p>
<p class="p4"><br></p>
<p class="p1">Perform an inverse FFT on a real and imaginary signal <b>in place</b>.</p>
<p class="p4"><br></p>
<p class="p7">(</p>
<p class="p7"><span class="s3">var</span> size = 512, real, imag, cosTable, complex, ifft;<span class="Apple-converted-space"> </span></p>
<p class="p6"><br></p>
<p class="p7">real = <span class="s3">Signal</span>.newClear(size);<span class="Apple-converted-space"> </span></p>
<p class="p9"><span class="s2"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span></span>// some harmonics</p>
<p class="p7">real.sineFill2([[8], [13, 0.5], [21, 0.25], [55, 0.125, 0.5pi]]);</p>
<p class="p9"><span class="s2"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span></span>// add a little noise</p>
<p class="p7">real.overDub(<span class="s3">Signal</span>.fill(size, { 0.2.bilinrand }));</p>
<p class="p6"><br></p>
<p class="p7">imag = <span class="s3">Signal</span>.newClear(size);</p>
<p class="p7">cosTable = <span class="s3">Signal</span>.fftCosTable(size);</p>
<p class="p6"><br></p>
<p class="p7">complex = fft(real, imag, cosTable).postln;</p>
<p class="p7">ifft = complex.real.ifft(complex.imag, cosTable);</p>
<p class="p6"><br></p>
<p class="p7">[real, ifft.real].flop.flat.plot(<span class="s6">"fft and back"</span>, <span class="s3">Rect</span>(0, 0, 512 + 8, 500), numChannels: 2);</p>
<p class="p7">)</p>
<p class="p6"><br></p>
<p class="p6"><br></p>
<p class="p4"><br></p>
<p class="p4"><br></p>
<p class="p5"><b><i>Unary Messages:</i></b></p>
<p class="p4"><br></p>
<p class="p1">Signal will respond to unary operators by returning a new Signal.</p>
<p class="p4"><br></p>
<p class="p1"><b>neg, abs, sign, squared, cubed, sqrt</b></p>
<p class="p1"><b>exp, log, log2, log10, sin, cos, tan, asin, acos, atan, sinh, cosh, tanh,<span class="Apple-converted-space"> </span></b></p>
<p class="p1"><b>distort, softclip, nyqring, isPositive, isNegative,<span class="Apple-converted-space"> </span></b></p>
<p class="p1"><b>isStrictlyPositive</b></p>
<p class="p4"><br></p>
<p class="p7">x = <span class="s3">Signal</span>.sineFill(512, [0, 0, 0, 1]);</p>
<p class="p7">[x, x.neg, x.abs, x.sign, x.squared, x.cubed,<span class="Apple-converted-space"> </span></p>
<p class="p7">x.asin.normalize, x.exp.normalize, x.distort].flop.flat.plot(numChannels: 9);</p>
<p class="p8"><br></p>
<p class="p8"><br></p>
<p class="p8"><br></p>
<p class="p4"><br></p>
<p class="p5"><b><i>Binary Messages:</i></b></p>
<p class="p10"><br></p>
<p class="p1">Signal will respond to binary operators by returning a new Signal.</p>
<p class="p4"><br></p>
<p class="p1"><b>+, -, *, /, div, %, **, min, max, ring1, ring2, ring3, ring4,<span class="Apple-converted-space"> </span></b></p>
<p class="p1"><b>difsqr, sumsqr, sqrdif, absdif, amclip,<span class="Apple-converted-space"> </span></b></p>
<p class="p1"><b>scaleneg, clip2, excess, &lt;!</b></p>
<p class="p4"><br></p>
<p class="p7">(</p>
<p class="p7">x = Signal.fill(512, { rrand(0.0, 1.0) });</p>
<p class="p7">y = Signal.fill(512, { |i| (i * pi / 64).sin });</p>
<p class="p7">[x, y, (x + y) * 0.5, x * y, min(x, y), max(x, y) ].flop.flat.plot(numChannels: 6);</p>
<p class="p7">)<span class="Apple-converted-space"> </span></p>
</body>
</html>
