<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta http-equiv="Content-Style-Type" content="text/css">
<title></title>
<meta name="Generator" content="Cocoa HTML Writer">
<meta name="CocoaVersion" content="1038.25">
<style type="text/css">
p.p1 {margin: 0.0px 0.0px 0.0px 0.0px; font: 14.0px Helvetica}
p.p2 {margin: 0.0px 0.0px 0.0px 0.0px; font: 12.0px Helvetica; min-height: 14.0px}
p.p3 {margin: 0.0px 0.0px 0.0px 0.0px; font: 12.0px Helvetica; color: #0000bf}
p.p4 {margin: 0.0px 0.0px 0.0px 0.0px; font: 12.0px Helvetica}
p.p5 {margin: 0.0px 0.0px 0.0px 0.0px; font: 14.0px Helvetica; min-height: 17.0px}
p.p6 {margin: 0.0px 0.0px 0.0px 0.0px; font: 9.0px Monaco}
p.p7 {margin: 0.0px 0.0px 0.0px 0.0px; font: 9.0px Monaco; min-height: 12.0px}
p.p8 {margin: 0.0px 0.0px 0.0px 0.0px; font: 12.0px 'Trebuchet MS'; min-height: 14.0px}
p.p9 {margin: 0.0px 0.0px 0.0px 0.0px; font: 9.0px Monaco; color: #bf0000}
p.p10 {margin: 0.0px 0.0px 0.0px 0.0px; font: 12.0px Helvetica; color: #0000bf; min-height: 14.0px}
p.p11 {margin: 0.0px 0.0px 0.0px 0.0px; font: 9.0px Monaco; color: #bf0000; min-height: 12.0px}
span.s1 {font: 18.0px Helvetica}
span.s2 {color: #000000}
span.s3 {color: #0000bf}
span.s4 {text-decoration: underline}
span.s5 {color: #0000bf}
span.s6 {color: #007300}
span.s7 {color: #bf0000}
span.s8 {text-decoration: underline ; color: #0000bf}
span.s9 {color: #0000bf}
span.Apple-tab-span {white-space:pre}
</style>
</head>
<body>
<p class="p1"><span class="s1"><b>UGen<span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span></b></span><b>abstract superclass of all unit generators</b></p>
<p class="p2"><br></p>
<p class="p3"><span class="s2"><b>Inherits from: </b><a href="../Core/Object.html"><b>Object</b></a></span><span class="s3"><b> </b></span><span class="s2"><b>: </b><a href="../Core/Kernel/AbstractFunction.html"><b>AbstractFunction</b></a></span></p>
<p class="p2"><br></p>
<p class="p4">UGens represent calculations with signals. They are the basic building blocks of synth definitions on the server, and are used to generate or process both audio and control signals. The many subclasses of UGen are the client-side representations of unit generators, and are used to specify their parameters when constructing synth definitions (see <a href="../ServerArchitecture/SynthDef.html"><span class="s3">SynthDef</span></a>).<span class="Apple-converted-space"> </span></p>
<p class="p2"><br></p>
<p class="p3"><span class="s2"><b>See also:</b> <a href="UGens.html"><span class="s4">UGens</span></a>, <a href="Tour_of_UGens.html"><span class="s4">Tour_of_UGens</span></a>, and <a href="../Tutorials/UGens-and-Synths.html"><span class="s4">UGens-and-Synths</span></a>.</span></p>
<p class="p2"><br></p>
<p class="p5"><br></p>
<p class="p5"><br></p>
<p class="p1"><b>Class Methods</b></p>
<p class="p5"><br></p>
<p class="p4"><b>*ar(arg1, arg2, ... )</b></p>
<p class="p4"><b>*kr(arg1, arg2, ... )</b></p>
<p class="p4"><b>*ir(arg1, arg2, ... )</b></p>
<p class="p2"><br></p>
<p class="p4">Return a new instance of UGen that calculates at <b>audio/control rate</b> or at <b>initialization only </b>(ir). Some UGens, like <a href="Random/Rand.html"><span class="s3">Rand</span></a>, use the *new method instead. These methods are implemented in subclasses, where argument names and their meaning depend on the case. If any argument is an <b>array</b>, they return an array of UGens (see: <a href="../Other Topics/MultiChannel.html"><span class="s3">MultiChannelExpansion</span></a>). If the combination of rates between arguments and ugen are not allowed, calling the methods will throw an error. This method adds the UGen to the current <a href="../ServerArchitecture/SynthDef.html"><span class="s3">SynthDef</span></a>, so it<span class="Apple-converted-space">  </span>only fully works inside a UGen function.</p>
<p class="p2"><br></p>
<p class="p6">{ <span class="s3">Blip</span>.ar(<span class="s3">Blip</span>.kr(4, 5, 500, 60), 59, 0.1) }.play;</p>
<p class="p7"><br></p>
<p class="p2"><br></p>
<p class="p4"><b>*buildSynthDef</b></p>
<p class="p2"><br></p>
<p class="p4">Return the SynthDef in which the UGen is situated.</p>
<p class="p7"><br></p>
<p class="p6">{ <span class="s5">UGen.</span>buildSynthDef.dump; Silent.ar }.play;</p>
<p class="p7"><br></p>
<p class="p5"><br></p>
<p class="p4"><b>Note: </b>For internally used class methods, see below.</p>
<p class="p7"><br></p>
<p class="p7"><br></p>
<p class="p5"><br></p>
<p class="p1"><b>Documentation of mul and add arguments</b></p>
<p class="p2"><br></p>
<p class="p4">A great number of UGens take arguments for <b>mul</b> and <b>add</b> in their <b>*ar</b> and <b>*kr </b>methods. Because these arguments are so ubiquitous, they are not general documented in the individual help files. Mul and add simply refer to a constant or signal by which to multiply the output of the UGen, and a constant or signal to add to the output of the UGen. (<b>mul</b> happens before <b>add</b>.) They thus correspond in many cases to scaling the amplitude of the UGen signal in the case of <b>mul</b>, and adding a constant or DC offset in the case of <b>add</b>. In most cases the defaults for mul and add are 1 and 0 respectively, and they are commonly implemented using a automatically generated <a href="Filters/MulAdd.html"><span class="s3">MulAdd</span></a> UGen for efficiency. See also the <b>range</b> and <b>madd</b> methods below.</p>
<p class="p2"><br></p>
<p class="p2"><br></p>
<p class="p1"><b>Convenience Methods</b></p>
<p class="p8"><br></p>
<p class="p2"><br></p>
<p class="p4"><b>scope(name, bufsize, zoom)</b></p>
<p class="p2"><br></p>
<p class="p4">Displays the output of this UGen in an individual <a href="../GUI/Main-GUI/Stethoscope.html"><span class="s3">Stethoscope</span></a><b> </b>window. <b>name</b> is the name of the window.</p>
<p class="p2"><br></p>
<p class="p9"><span class="s3">Server</span><span class="s2">.default = s = </span><span class="s3">Server</span><span class="s2">.internal.boot; </span>// scope works only for internal server</p>
<p class="p7"><br></p>
<p class="p6">{ <span class="s3">Ringz</span>.ar(<span class="s3">PinkNoise</span>.ar([0.1, 0.2]).scope(<span class="s6">\pink</span>), 2000, 1, 0.25) }.play; <span class="s7">// multichannel works</span></p>
<p class="p9"><span class="s2">s.scope; </span>// can still separately scope the output of the server</p>
<p class="p7"><br></p>
<p class="p9"><span class="s3">Server</span><span class="s2">.default = s = </span><span class="s3">Server</span><span class="s2">.local.boot; </span>// switch back to local server.</p>
<p class="p2"><br></p>
<p class="p2"><br></p>
<p class="p2"><br></p>
<p class="p4"><b>poll(trig, label, trigid)</b></p>
<p class="p2"><br></p>
<p class="p2"><br></p>
<p class="p4">Polls the output of this UGen every <b>interval</b> seconds, and posts the result. The default <b>trig </b>is 10, which converts to 10 triggers per second (or every 0.1 seconds). See <a href="Triggers/Poll.html"><span class="s3">Poll</span></a> for more info on polling.</p>
<p class="p2"><br></p>
<p class="p6">{ <span class="s3">SinOsc</span>.ar(<span class="s3">LFNoise0</span>.ar(2).range(420, 460).poll(label: <span class="s6">\LFNoise</span>), 0, 0.2) }.play;</p>
<p class="p7"><br></p>
<p class="p9">// multichannel polling:</p>
<p class="p6">(</p>
<p class="p6">{<span class="Apple-converted-space"> </span></p>
<p class="p6"><span class="Apple-tab-span">	</span><span class="s3">var</span> freqs = <span class="s3">SinOsc</span>.ar([0.2, 0.3]).range(420, 460);</p>
<p class="p6"><span class="Apple-tab-span">	</span>freqs.poll(label: [<span class="s6">\freq1</span>, <span class="s6">\freq2</span>]);</p>
<p class="p6"><span class="Apple-tab-span">	</span><span class="s3">SinOsc</span>.ar(freqs, 0, 0.2);</p>
<p class="p6">}.play;</p>
<p class="p6">)</p>
<p class="p7"><br></p>
<p class="p4"><b>dpoll(trig, label, trigid)</b></p>
<p class="p2"><br></p>
<p class="p2"><br></p>
<p class="p4">Like poll, only that <b>dpoll</b> is used for Demand ugens. See <a href="Triggers/Poll.html"><span class="s5">Poll</span></a> for more info on polling.</p>
<p class="p7"><br></p>
<p class="p2"><br></p>
<p class="p4"><b>range(lo, hi)</b></p>
<p class="p2"><br></p>
<p class="p4">Scales the output of this UGen to be within the range of <b>lo</b> and <b>hi</b>. Note that 'range' expects the default output range, and thus should not be used in conjunction with <b>mul</b> and <b>add</b> arguments.</p>
<p class="p2"><br></p>
<p class="p6">{ <span class="s3">SinOsc</span>.ar(<span class="s3">SinOsc</span>.ar(0.3).range(440, 660), 0, 0.5) * 0.1 }.play;</p>
<p class="p2"><br></p>
<p class="p4"><b>exprange(lo, hi)</b></p>
<p class="p2"><br></p>
<p class="p4">Maps the output of this UGen exponentially to be within the range of <b>lo</b> and <b>hi</b> using a <a href="Filters/LinExp.html"><span class="s3">LinExp</span></a> UGen. <b>lo</b> and <b>hi</b> should both be non-zero and have the same sign. Note that 'exprange' expects the default output range, and thus should not be used in conjunction with <b>mul</b> and <b>add</b> arguments.</p>
<p class="p2"><br></p>
<p class="p6">{ <span class="s3">SinOsc</span>.ar(<span class="s3">SinOsc</span>.ar(0.3).exprange(440, 6600), 0, 0.5) * 0.1 }.play;</p>
<p class="p2"><br></p>
<p class="p4"><b>unipolar(mul)</b></p>
<p class="p2"><br></p>
<p class="p4">Scales the output of this UGen to be between <b>(0..mul)</b> range (default 1). Note that 'unipolar' expects the default output range, and thus should not be used in conjunction with <b>mul</b> and <b>add</b> arguments.</p>
<p class="p2"><br></p>
<p class="p6">{ <span class="s3">SinOsc</span>.ar(300, 0, 0.5) * <span class="s3">SinOsc</span>.kr(2).unipolar * 0.1 }.play;</p>
<p class="p2"><br></p>
<p class="p2"><br></p>
<p class="p4"><b>bipolar(mul)</b></p>
<p class="p2"><br></p>
<p class="p4">Scales the output of this UGen to be between <b>(-mul..mul)</b> range (default 1). Note that 'bipolar' expects the default output range, and thus should not be used in conjunction with <b>mul</b> and <b>add</b> arguments.</p>
<p class="p2"><br></p>
<p class="p6">{ <span class="s3">SinOsc</span>.ar(500 + <span class="s3">LFPulse</span>.ar(4).bipolar(40), 0, 0.5) * 0.1 }.play;</p>
<p class="p2"><br></p>
<p class="p2"><br></p>
<p class="p4"><b>clip(lo, hi)</b></p>
<p class="p2"><br></p>
<p class="p4">Wraps the receiver in a <a href="Filters/Clip.html"><span class="s3">Clip</span></a><b> </b>UGen, clipping its output at <b>lo</b> and <b>hi</b>.</p>
<p class="p2"><br></p>
<p class="p4"><b>fold(lo, hi)</b></p>
<p class="p2"><br></p>
<p class="p4">Wraps the receiver in a <a href="Filters/Fold.html"><span class="s3">Fold</span></a><b> </b>UGen, folding its output at <b>lo</b> and <b>hi</b>.</p>
<p class="p2"><br></p>
<p class="p4"><b>wrap(lo, hi)</b></p>
<p class="p2"><br></p>
<p class="p4">Wraps the receiver in a <a href="Filters/Wrap.html"><span class="s3">Wrap</span></a><b> </b>UGen, wrapping its output at <b>lo</b> and <b>hi</b>.</p>
<p class="p2"><br></p>
<p class="p4"><b>lag(lagTime, t2)</b></p>
<p class="p2"><br></p>
<p class="p4">Wraps the receiver in a <a href="Filters/Lag.html"><span class="s3">Lag</span></a><b> </b>UGen, smoothing its output by lagTime. If a second argument is given, it wraps it in a <a href="Filters/LagUD.html"><span class="s3">LagUD</span></a><span class="s3"> </span>UGen. Default lag time: 0.1.</p>
<p class="p10"><br></p>
<p class="p4"><b>lag2(lagTime, t2)</b></p>
<p class="p10"><br></p>
<p class="p4">Wraps the receiver in a<span class="Apple-converted-space"> </span><a href="Filters/LagUD.html"><span class="s8"> </span></a><a href="Filters/Lag2.html"><span class="s3">Lag2</span></a><b> </b>UGen, smoothing its output by lagTime. If a second argument is given, it wraps it in a <a href="Filters/Lag2UD.html"><span class="s3">Lag2UD</span></a><span class="s3"> </span>UGen. Default lag time: 0.1.</p>
<p class="p10"><br></p>
<p class="p4"><b>lag3(lagTime, t2)</b></p>
<p class="p10"><br></p>
<p class="p4">Wraps the receiver in a <a href="Filters/Lag3.html"><span class="s3">Lag3</span></a><b> </b>UGen, smoothing its output by lagTime. If a second argument is given, it wraps it in a <a href="Filters/Lag3UD.html"><span class="s3">Lag3UD</span></a><span class="s3"> </span>UGen. Default lag time: 0.1.</p>
<p class="p10"><br></p>
<p class="p4"><b>lagud(lagTimeU, lagTimeD)</b></p>
<p class="p10"><br></p>
<p class="p4">Wraps the receiver in a<span class="Apple-converted-space"> </span><a href="Filters/Lag3UD.html"><span class="s8"> </span></a><a href="Filters/LagUD.html"><span class="s3">LagUD</span></a><b> </b>UGen, smoothing its output by lagtimeU and lagtimeD. Default lag time: 0.1.</p>
<p class="p2"><br></p>
<p class="p4"><b>lag2ud(lagtimeU,lagtimeD)</b></p>
<p class="p2"><br></p>
<p class="p4">Wraps the receiver in a <a href="Filters/Lag2UD.html"><span class="s3">Lag2UD</span></a><b> </b>UGen, smoothing its output by lagtimeU and lagtimeD. Default lag time: 0.1.</p>
<p class="p2"><br></p>
<p class="p4"><b>lag3ud(lagtimeU, lagtimeD)</b></p>
<p class="p2"><br></p>
<p class="p4">Wraps the receiver in a <a href="Filters/Lag3UD.html"><span class="s3">Lag3UD</span></a><b> </b>UGen, smoothing its output by lagtimeU and lagtimeD. Default lag time: 0.1.</p>
<p class="p2"><br></p>
<p class="p4"><b>degreeToKey(scale, stepsPerOctave)</b></p>
<p class="p2"><br></p>
<p class="p4">Wraps the receiver in a <a href="Synth control/DegreeToKey.html"><span class="s3">DegreeToKey</span></a><b> </b>UGen. The default <b>stepsPerOctave</b> is 12.</p>
<p class="p2"><br></p>
<p class="p4"><b>minNyquist</b></p>
<p class="p2"><br></p>
<p class="p4">Wraps the receiver in a <a href="../BinaryOps/min.html"><span class="s3">min</span></a><b> </b>UGen, such that the lesser of the receiver's output and the Nyquist frequency is output. This can be useful to prevent aliasing.</p>
<p class="p2"><br></p>
<p class="p4"><b>linlin(inMin, inMax, outMin, outMax, clip)</b></p>
<p class="p2"><br></p>
<p class="p4">Wraps the receiver so that a linear inputrange is mapped to a linear output range.<span class="Apple-converted-space"> </span></p>
<p class="p4">The <b>clip</b> argument can be one of the four:<span class="Apple-converted-space"> </span></p>
<p class="p4"><b>nil</b> (do not clip at outMin or outMax),<span class="Apple-converted-space"> </span></p>
<p class="p4"><b>\minmax</b> (clip at outMin or outMax),<span class="Apple-converted-space"> </span></p>
<p class="p4"><b>\min</b> (clip at outMin),</p>
<p class="p4"><b>\max </b>(clip at outMax)</p>
<p class="p2"><br></p>
<p class="p6">{ <span class="s3">Line</span>.ar(-1, 5, 0.1).linlin(0, 3, -1, 1) }.plot(0.1);</p>
<p class="p11"><br></p>
<p class="p9">// modulate some values</p>
<p class="p9">(</p>
<p class="p6">{ <span class="s3">Line</span>.ar(-1, 5, 0.1).lincurve(<span class="s3">SinOsc</span>.ar(100), <span class="s3">SinOsc</span>.ar(130) + 3, -1, 1, clip: nil) }</p>
<p class="p6"><span class="Apple-tab-span">	</span>.plot(0.1, minval: -15, maxval: 5)</p>
<p class="p6">)</p>
<p class="p2"><br></p>
<p class="p4"><b>linexp(inMin, inMax, outMin, outMax, clip)</b></p>
<p class="p2"><br></p>
<p class="p4">Wraps the receiver so that a linear inputrange is mapped to an exponential output range.</p>
<p class="p4">outMin and outMax must be nonzero and of the same sign. For <b>clip </b>argument, see <b>linlin</b>.</p>
<p class="p2"><br></p>
<p class="p6">{ <span class="s3">Line</span>.ar(-1, 5, 0.1).linexp(0, 3, 0.01, 1) }.plot(0.1);</p>
<p class="p2"><br></p>
<p class="p4"><b>explin(inMin, inMax, outMin, outMax, clip)</b></p>
<p class="p2"><br></p>
<p class="p4">Wraps the receiver so that an exponential inputrange is mapped to a linear output range.</p>
<p class="p4">inMin and inMax must be nonzero and of the same sign. For <b>clip </b>argument, see <b>linlin</b>.</p>
<p class="p2"><br></p>
<p class="p6">{ <span class="s3">Line</span>.ar(1, 5, 0.1).explin(1, 3, -1, 1) }.plot(0.1);</p>
<p class="p2"><br></p>
<p class="p4"><b>expexp(inMin, inMax, outMin, outMax, clip)</b></p>
<p class="p2"><br></p>
<p class="p4">Wraps the receiver so that an exponential inputrange is mapped to an exponential output range.</p>
<p class="p4">outMin, outMax, inMin and inMax must be nonzero and of the same sign. For <b>clip </b>argument, see <b>linlin</b>.</p>
<p class="p2"><br></p>
<p class="p6">{ <span class="s3">Line</span>.ar(1, 5, 0.1).expexp(1, 3, 0.01, 1) }.plot(0.1);</p>
<p class="p2"><br></p>
<p class="p2"><br></p>
<p class="p4"><b>lincurve(inMin, inMax, outMin, outMax, curve, clip)</b></p>
<p class="p2"><br></p>
<p class="p4">Wraps the receiver so that a linear inputrange is mapped to a curve-like exponential output range.</p>
<p class="p4">outMin and outMax may be zero and of the different sign. For <b>clip </b>argument, see <b>linlin</b>.</p>
<p class="p2"><br></p>
<p class="p2"><br></p>
<p class="p6">{ <span class="s3">Line</span>.ar(-1, 5, 0.1).lincurve(0, 3, -1, 1, curve: -4) }.plot(0.1);</p>
<p class="p7"><br></p>
<p class="p9">// modulate the curve. Unlike with numbers and CurveSpec, the curve absolute value<span class="Apple-converted-space"> </span></p>
<p class="p9">// should not be much smaller than 0.5.</p>
<p class="p6">{ <span class="s3">SinOsc</span>.ar(100).lincurve(-1, 1, -1, 1, <span class="s3">XLine</span>.kr(-3, -100, 0.1)) * 0.1 }.plot(0.1);</p>
<p class="p2"><br></p>
<p class="p2"><br></p>
<p class="p4"><b>curvelin(inMin, inMax, outMin, outMax, curve, clip)</b></p>
<p class="p2"><br></p>
<p class="p4">Wraps the receiver so that a<span class="Apple-converted-space">  </span>curve-like exponential inputrange is mapped to a linear output range.</p>
<p class="p4">inMin and inMax<span class="Apple-converted-space">  </span>may be zero and of the different sign.<span class="Apple-converted-space">  </span>For <b>clip </b>argument, see <b>linlin</b>.</p>
<p class="p2"><br></p>
<p class="p6">{ <span class="s3">Line</span>.ar(-1, 5, 0.1).curvelin(0, 3, -1, 1, curve: -4) }.plot(0.1);</p>
<p class="p2"><br></p>
<p class="p2"><br></p>
<p class="p4"><b>prune(min, max, clip)</b></p>
<p class="p2"><br></p>
<p class="p4">Limits the receiver range to one of the four <b>clip</b> modes (see <b>linlin</b>)</p>
<p class="p2"><br></p>
<p class="p4"><b>checkBadValues(id, post)</b></p>
<p class="p2"><br></p>
<p class="p4">Wraps the receiver in a <a href="Info/CheckBadValues.html"><span class="s3">CheckBadValues</span></a> UGen with the corresponding id and post flag.</p>
<p class="p2"><br></p>
<p class="p4"><b>if(trueUGen, falseUGen)</b></p>
<p class="p2"><br></p>
<p class="p4">Outputs <b>trueUGen</b> when the receiver outputs 1, <b>falseUGen</b> when the receiver outputs 0. If the receiver outputs a value between 0 and 1, a mixture of both will be played. (This is implemented as: ^(this * (trueUGen - falseUGen)) + falseUGen) Note that both <b>trueUGen</b> and <b>falseUGen</b> will be calculated regardless of whether they are output, so this may not be the most efficient approach.</p>
<p class="p2"><br></p>
<p class="p9">// note different syntax in these two examples</p>
<p class="p6">{ if( <span class="s3">LFNoise1</span>.kr(1.0, 0.5, 0.5) , <span class="s3">SinOsc</span>.ar, <span class="s3">Saw</span>.ar ) * 0.1 }.play;</p>
<p class="p7"><br></p>
<p class="p6">{ <span class="s3">Trig1</span>.ar(<span class="s3">Dust</span>.ar(3), 0.2).lag(0.1).if(<span class="s3">FSinOsc</span>.ar(440), <span class="s3">FSinOsc</span>.ar(880)) * 0.1 }.play;</p>
<p class="p2"><br></p>
<p class="p4"><b>@ y</b></p>
<p class="p2"><br></p>
<p class="p4">Dynamic geometry support. Returns <b>Point(this, y)</b>.</p>
<p class="p2"><br></p>
<p class="p6">{ (<span class="s3">SinOsc</span>.ar(1001) @ <span class="s3">SinOsc</span>.ar(1207)).rho }.scope;</p>
<p class="p2"><br></p>
<p class="p4"><b>asComplex</b></p>
<p class="p2"><br></p>
<p class="p4">Complex math support. Returns <b>Complex(this, 0.0)</b>.</p>
<p class="p2"><br></p>
<p class="p4"><b>dumpArgs</b></p>
<p class="p4">        </p>
<p class="p4">Posts a list of the arguments for this UGen and their values.</p>
<p class="p2"><br></p>
<p class="p2"><br></p>
<p class="p2"><br></p>
<p class="p2"><br></p>
<p class="p1"><b>Other Instance Methods</b></p>
<p class="p2"><br></p>
<p class="p4">The following methods and instance variables are largely used in the construction of synth definitions, synth descriptions (see <a href="../ServerArchitecture/SynthDesc.html"><span class="s3">SynthDesc</span></a>), UGen class definitions, etc., and are usually not needed for general use. Users should not attempt to set any of these values in general code.</p>
<p class="p2"><br></p>
<p class="p4"><b>synthDef</b></p>
<p class="p2"><br></p>
<p class="p4">The SynthDef which contains the UGen.</p>
<p class="p2"><br></p>
<p class="p4"><b>inputs</b></p>
<p class="p2"><br></p>
<p class="p4">The array of inputs to the UGen.<span class="Apple-converted-space"> </span></p>
<p class="p2"><br></p>
<p class="p4"><b>rate</b></p>
<p class="p2"><br></p>
<p class="p4">The output rate of the UGen which is one of the Symbols 'audio', or 'control'.</p>
<p class="p2"><br></p>
<p class="p2"><br></p>
<p class="p4"><b>signalRange</b></p>
<p class="p2"><br></p>
<p class="p4">Returns a symbol indicating the signal range of the receiver. Either <span class="s6">\bipolar</span> or <span class="s6">\unipolar</span>.</p>
<p class="p2"><br></p>
<p class="p4"><b>numChannels</b> </p>
<p class="p2"><br></p>
<p class="p4">Returns the number of output Channels. For a UGen, this will always be 1, but <a href="../Collections/Array.html"><span class="s3">Array</span></a> also implements this method, so multichannel expansion is supported. See <a href="../Other Topics/MultiChannel.html"><span class="s3">MultiChannel</span></a>.</p>
<p class="p2"><br></p>
<p class="p4"><b>numInputs</b></p>
<p class="p2"><br></p>
<p class="p4">Returns the number of inputs for this UGen.</p>
<p class="p2"><br></p>
<p class="p4"><b>numOutputs</b></p>
<p class="p2"><br></p>
<p class="p4">Returns the number of outputs for this UGen.</p>
<p class="p2"><br></p>
<p class="p4"><b>name</b></p>
<p class="p2"><br></p>
<p class="p4">Returns the <a href="../Core/Kernel/Class.html"><span class="s3">Class</span></a> name of the receiver as a <a href="../Collections/String.html"><span class="s3">String</span></a>.</p>
<p class="p2"><br></p>
<p class="p4"><b>madd(mul, add)</b></p>
<p class="p2"><br></p>
<p class="p4">Wraps the receiver in a <a href="Filters/MulAdd.html"><span class="s3">MulAdd</span></a> UGen. This is for the most part only used in UGen class definitions in order to allow efficient implementation of <b>mul</b> and <b>add</b> arguments.</p>
<p class="p2"><br></p>
<p class="p4"><b>isValidUGenInput</b></p>
<p class="p2"><br></p>
<p class="p4">Returns true.</p>
<p class="p2"><span class="Apple-tab-span">	</span></p>
<p class="p4"><b>asUGenInput</b></p>
<p class="p2"><br></p>
<p class="p4">Returns the receiver. This method is implemented in a number of classes in order to allow objects like Nodes, Busses, and Buffers to be passed directly as UGen inputs and Synth args.<span class="Apple-tab-span">	</span></p>
<p class="p2"><br></p>
<p class="p4"><b>copy</b></p>
<p class="p2"><br></p>
<p class="p4">Returns the receiver. Thus UGen-dup effectively returns a reference to the original and is a convenient way to copy a mono signal to multiple channels.</p>
<p class="p2"><br></p>
<p class="p6">{ <span class="s3">SinOsc</span>.ar(<span class="s3">Rand</span>(200, 4000), 0, 0.2).dup }.plot <span class="s7">// this is the same UGen</span></p>
<p class="p4">    </p>
<p class="p4">Function-dup evaluates that function multiple times, thus potentially returning distinct UGens.</p>
<p class="p2"><br></p>
<p class="p6">{ { <span class="s3">SinOsc</span>.ar(<span class="s3">Rand</span>(200, 4000), 0, 0.2) }.dup }.plot <span class="s7">// these are different UGens</span></p>
<p class="p7"><br></p>
<p class="p7"><br></p>
<p class="p7"><br></p>
<p class="p7"><br></p>
<p class="p1"><b>Internally used methods</b></p>
<p class="p5"><br></p>
<p class="p5"><br></p>
<p class="p4"><b>*multiNew(rate, ...args)</b></p>
<p class="p4"><b>*multiNewList([rate, ...args])</b></p>
<p class="p2"><br></p>
<p class="p4">These methods are responsible for multichannel expansion. They call <b>*new1(rate, ...args)</b> for each parallel combination. Most *ar/*kr methods delegate to multiNewList.</p>
<p class="p2"><br></p>
<p class="p4"><b>*new1(rate, ...args)</b></p>
<p class="p2"><br></p>
<p class="p4">This method returns a single instance of the UGen, not multichannel expanded. It is called inside multiNewList, whenever a new single instance is needed.</p>
<p class="p2"><br></p>
<p class="p4"><b>*methodSelectorForRate(rate)</b></p>
<p class="p4"><b>methodSelectorForRate(rate)</b></p>
<p class="p2"><br></p>
<p class="p4">Returns an appropriate message selector (Symbol like \ar, \kr, \ir) for a given rate like \audio, \control, \scalar.</p>
<p class="p2"><br></p>
<p class="p4"><b>*replaceZeroesWithSilence(array)</b></p>
<p class="p2"><br></p>
<p class="p4">Returns a new array, where every zero is replaced by a <a href="Synth control/Silent.html"><span class="s9">Silent</span></a> UGen. This is required internally sometimes for UGens like <a href="InOut/Out.html"><span class="s9">Out</span></a>.</p>
<p class="p2"><br></p>
<p class="p4"><b>init(... theInputs)</b></p>
<p class="p2"><br></p>
<p class="p4">By default, this method stores the inputs (e.g. the arguments to *ar and *kr) in the UGen. This may be overridden to do other initialisations, as long as the inputs are set correctly.</p>
<p class="p7"><br></p>
</body>
</html>
