<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta http-equiv="Content-Style-Type" content="text/css">
<title></title>
<meta name="Generator" content="Cocoa HTML Writer">
<meta name="CocoaVersion" content="1038.35">
<style type="text/css">
p.p1 {margin: 0.0px 0.0px 0.0px 0.0px; font: 12.0px Helvetica}
p.p2 {margin: 0.0px 0.0px 0.0px 0.0px; font: 12.0px Helvetica; min-height: 14.0px}
p.p3 {margin: 0.0px 0.0px 0.0px 0.0px; font: 14.0px Helvetica}
p.p4 {margin: 0.0px 0.0px 0.0px 0.0px; font: 9.0px Monaco}
p.p5 {margin: 0.0px 0.0px 0.0px 0.0px; font: 9.0px Monaco; min-height: 12.0px}
p.p6 {margin: 0.0px 0.0px 0.0px 0.0px; font: 9.0px Monaco; color: #ad140d}
p.p7 {margin: 0.0px 0.0px 0.0px 0.0px; font: 9.0px Monaco; color: #606060}
p.p8 {margin: 0.0px 0.0px 0.0px 0.0px; font: 9.0px Monaco; color: #ad140d; min-height: 12.0px}
p.p9 {margin: 0.0px 0.0px 0.0px 0.0px; font: 9.0px Monaco; color: #cd1612}
p.p10 {margin: 0.0px 0.0px 0.0px 0.0px; font: 12.0px Helvetica; color: #0000ee}
span.s1 {font: 18.0px Helvetica}
span.s2 {color: #001bb9}
span.s3 {text-decoration: underline}
span.s4 {color: #000000}
span.s5 {color: #606060}
span.s6 {font: 9.0px Monaco}
span.s7 {font: 12.0px Helvetica}
span.s8 {color: #ad140d}
span.s9 {color: #1738f5}
span.s10 {color: #1135f9}
span.s11 {color: #0a25b9}
span.s12 {color: #0b28c5}
span.s13 {color: #0b28c6}
span.s14 {font: 12.0px Helvetica; color: #000000}
span.Apple-tab-span {white-space:pre}
</style>
</head>
<body>
<p class="p1"><span class="s1"><b>SimpleNumber<span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span></b></span><b>one dimensional value</b></p>
<p class="p2"><br></p>
<p class="p1"><b>superclass: Number</b></p>
<p class="p2"><br></p>
<p class="p1">Represents numbers which can be represented by a single one dimensional value.</p>
<p class="p2"><br></p>
<p class="p1">Most of the Unary and Binary operations are also implemented by <a href="../UGens/Algebraic/UnaryOpUGen.html"><span class="s2">UnaryOpUGen</span></a></p>
<p class="p1">and <a href="../UGens/Algebraic/BinaryOpUGen.html"><span class="s2">BinaryOpUGen</span></a>, so you can get more examples by looking at the help for those.</p>
<p class="p2"><br></p>
<p class="p2"><br></p>
<p class="p3"><b>Unary Operations</b></p>
<p class="p2"><br></p>
<p class="p1"><b>neg</b></p>
<p class="p2"><br></p>
<p class="p1">negation</p>
<p class="p2"><br></p>
<p class="p1"><b>bitNot</b></p>
<p class="p2"><br></p>
<p class="p1">ones complement</p>
<p class="p2"><br></p>
<p class="p1"><b>abs</b></p>
<p class="p2"><br></p>
<p class="p1">absolute value.</p>
<p class="p2"><br></p>
<p class="p1"><b>ceil</b></p>
<p class="p2"><br></p>
<p class="p1">next larger integer.</p>
<p class="p2"><br></p>
<p class="p1"><b>floor</b></p>
<p class="p2"><br></p>
<p class="p1">next smaller integer</p>
<p class="p2"><br></p>
<p class="p1"><b>frac</b></p>
<p class="p2"><br></p>
<p class="p1">fractional part.</p>
<p class="p2"><br></p>
<p class="p1"><b>sign</b></p>
<p class="p2"><br></p>
<p class="p1">Answer -1 if negative, +1 if positive or 0 if zero.</p>
<p class="p2"><br></p>
<p class="p1"><b>squared</b></p>
<p class="p2"><br></p>
<p class="p1">The square of the number.</p>
<p class="p2"><br></p>
<p class="p1"><b>cubed</b></p>
<p class="p2"><br></p>
<p class="p1">The cube of the number.</p>
<p class="p2"><br></p>
<p class="p1"><b>sqrt</b></p>
<p class="p2"><br></p>
<p class="p1">The square root of the number.</p>
<p class="p2"><br></p>
<p class="p1"><b>exp</b></p>
<p class="p2"><br></p>
<p class="p1">e to the power of the receiver.</p>
<p class="p2"><br></p>
<p class="p1"><b>reciprocal</b></p>
<p class="p2"><br></p>
<p class="p1">1 / this</p>
<p class="p2"><br></p>
<p class="p1"><b>midicps</b></p>
<p class="p2"><br></p>
<p class="p1">Convert MIDI note to cycles per second</p>
<p class="p2"><br></p>
<p class="p1"><b>cpsmidi</b></p>
<p class="p2"><br></p>
<p class="p1">Convert cycles per second to MIDI note.</p>
<p class="p2"><br></p>
<p class="p1"><b>midiratio</b></p>
<p class="p2"><br></p>
<p class="p1">Convert an interval in semitones to a ratio.</p>
<p class="p2"><br></p>
<p class="p1"><b>ratiomidi</b></p>
<p class="p2"><br></p>
<p class="p1">Convert a ratio to an interval in semitones.</p>
<p class="p2"><br></p>
<p class="p1"><b>ampdb</b></p>
<p class="p2"><br></p>
<p class="p1">Convert a linear amplitude to decibels.</p>
<p class="p2"><br></p>
<p class="p1"><b>dbamp</b></p>
<p class="p2"><br></p>
<p class="p1">Convert a decibels to a linear amplitude.</p>
<p class="p2"><br></p>
<p class="p1"><b>octcps</b></p>
<p class="p2"><br></p>
<p class="p1">Convert decimal octaves to cycles per second.</p>
<p class="p2"><br></p>
<p class="p1"><b>cpsoct</b></p>
<p class="p2"><br></p>
<p class="p1">Convert cycles per second to decimal octaves.</p>
<p class="p2"><br></p>
<p class="p1"><b>log</b></p>
<p class="p2"><br></p>
<p class="p1">Base e logarithm.</p>
<p class="p2"><br></p>
<p class="p1"><b>log2</b></p>
<p class="p2"><br></p>
<p class="p1">Base 2 logarithm.</p>
<p class="p2"><br></p>
<p class="p1"><b>log10</b></p>
<p class="p2"><br></p>
<p class="p1">Base 10 logarithm.</p>
<p class="p2"><br></p>
<p class="p1"><b>sin</b></p>
<p class="p2"><br></p>
<p class="p1">Sine.</p>
<p class="p2"><br></p>
<p class="p1"><b>cos</b></p>
<p class="p2"><br></p>
<p class="p1">Cosine.</p>
<p class="p2"><br></p>
<p class="p1"><b>tan</b></p>
<p class="p2"><br></p>
<p class="p1">Tangent.</p>
<p class="p2"><br></p>
<p class="p1"><b>asin</b></p>
<p class="p2"><br></p>
<p class="p1">Arcsine.</p>
<p class="p2"><br></p>
<p class="p1"><b>acos</b></p>
<p class="p2"><br></p>
<p class="p1">Arccosine.</p>
<p class="p2"><br></p>
<p class="p1"><b>atan</b></p>
<p class="p2"><br></p>
<p class="p1">Arctangent.</p>
<p class="p2"><br></p>
<p class="p1"><b>sinh</b></p>
<p class="p2"><br></p>
<p class="p1">Hyperbolic sine.</p>
<p class="p2"><br></p>
<p class="p1"><b>cosh</b></p>
<p class="p2"><br></p>
<p class="p1">Hyperbolic cosine.</p>
<p class="p2"><br></p>
<p class="p1"><b>tanh</b></p>
<p class="p2"><br></p>
<p class="p1">Hyperbolic tangent.</p>
<p class="p2"><br></p>
<p class="p1"><b>rand</b></p>
<p class="p2"><br></p>
<p class="p1">Random number from zero up to the receiver, exclusive.</p>
<p class="p2"><br></p>
<p class="p1"><b>rand2</b></p>
<p class="p2"><br></p>
<p class="p1">Random number from -this to +this.</p>
<p class="p2"><br></p>
<p class="p1"><b>linrand</b></p>
<p class="p2"><br></p>
<p class="p1">Linearly distributed random number from zero to this.</p>
<p class="p2"><br></p>
<p class="p1"><b>bilinrand</b></p>
<p class="p2"><br></p>
<p class="p1">Bilateral linearly distributed random number from -this to +this.</p>
<p class="p2"><br></p>
<p class="p1"><b>sum3rand</b></p>
<p class="p2"><br></p>
<p class="p1">A random number<span class="Apple-converted-space">  </span>from -this to +this that is the result of summing three uniform random generators</p>
<p class="p1">to yield a bell-like distribution. This was suggested by Larry Polansky as a poor man's gaussian.</p>
<p class="p2"><br></p>
<p class="p1"><b>distort</b></p>
<p class="p2"><br></p>
<p class="p1">a nonlinear distortion function.</p>
<p class="p2"><br></p>
<p class="p1"><b>softclip</b></p>
<p class="p2"><br></p>
<p class="p1">Distortion with a perfectly linear region from -0.5 to +0.5</p>
<p class="p2"><br></p>
<p class="p1"><b>scurve</b></p>
<p class="p2"><br></p>
<p class="p1">Map receiver in the onto an S-curve.</p>
<p class="p2"><br></p>
<p class="p4">((0..100) / 100 ).collect(_.scurve).plot</p>
<p class="p5"><br></p>
<p class="p1"><b>ramp</b></p>
<p class="p2"><br></p>
<p class="p1">Map receiver onto a ramp starting at 0.</p>
<p class="p2"><br></p>
<p class="p4">((-100..100) / 100 ).collect(_.ramp).plot</p>
<p class="p2"><br></p>
<p class="p1"><b>coin</b></p>
<p class="p2"><br></p>
<p class="p1">Answers a Boolean which is the result of a random test whose probability of success in a range from<span class="Apple-converted-space"> </span></p>
<p class="p1">zero to one is <span class="s3">this</span>.</p>
<p class="p2"><br></p>
<p class="p1"><b>even</b></p>
<p class="p2"><br></p>
<p class="p1">Answer if the number is even.</p>
<p class="p2"><br></p>
<p class="p1"><b>odd</b></p>
<p class="p2"><br></p>
<p class="p1">Answer if the number is odd.</p>
<p class="p2"><br></p>
<p class="p1"><b>isPositive</b></p>
<p class="p2"><br></p>
<p class="p1">Answer if the number is &gt;= 0.</p>
<p class="p2"><br></p>
<p class="p1"><b>isNegative</b></p>
<p class="p2"><br></p>
<p class="p1">Answer if the number is &lt; 0.</p>
<p class="p2"><br></p>
<p class="p1"><b>isStrictlyPositive</b></p>
<p class="p2"><br></p>
<p class="p1">Answer if the number is &gt; 0.</p>
<p class="p2"><br></p>
<p class="p1"><b>booleanValue</b></p>
<p class="p2"><br></p>
<p class="p1">return true, if strictly positive ( &gt; 0), otherwise false (see <a href="../Core/Boolean.html"><span class="s2">Boolean</span></a>)</p>
<p class="p2"><br></p>
<p class="p1"><b>isValidUGenInput</b></p>
<p class="p2"><br></p>
<p class="p1">return false if receiver cannot be used in UGen.</p>
<p class="p2"><br></p>
<p class="p1"><b>magnitude</b></p>
<p class="p2"><br></p>
<p class="p1">returns abolute value (see <a href="Polar.html"><span class="s2">Polar</span></a>, <a href="Complex.html"><span class="s2">Complex</span></a>)</p>
<p class="p2"><br></p>
<p class="p1"><b>angle</b></p>
<p class="p2"><br></p>
<p class="p1">returns angle of receiver conceived as <a href="Polar.html"><span class="s2">Polar</span></a> or <a href="Complex.html"><span class="s2">Complex</span></a><span class="s2"> </span>number.</p>
<p class="p2"><br></p>
<p class="p1"><b>wait</b></p>
<p class="p1"><span class="Apple-tab-span">	</span>within a routine, yield the number so that the clock can wait for this many beats.</p>
<p class="p1"><span class="Apple-tab-span">	</span>(see <a href="../Core/Kernel/Routine.html"><span class="s2">Routine</span></a>)</p>
<p class="p2"><span class="Apple-tab-span">	</span></p>
<p class="p6"><span class="s4"><span class="Apple-tab-span">	</span></span>// create a routine by a function fork</p>
<p class="p4"><span class="Apple-tab-span">	</span>(</p>
<p class="p4"><span class="Apple-tab-span">	</span>fork {</p>
<p class="p4"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>1.wait;</p>
<p class="p7"><span class="s4"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span></span>"I did wait"<span class="s4">.postln;</span></p>
<p class="p4"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>1.0.rand.wait;</p>
<p class="p7"><span class="s4"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span></span>"No you didn't"<span class="s4">.postln;</span></p>
<p class="p4"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>2.wait;</p>
<p class="p4"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>(1..).do { <span class="s2">|i|</span><span class="Apple-converted-space"> </span></p>
<p class="p4"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="s5">"yes I did"</span>.postln;<span class="Apple-converted-space"> </span></p>
<p class="p4"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>i.asFloat.rand.wait;<span class="Apple-converted-space"> </span></p>
<p class="p7"><span class="s4"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span></span>"no you didn't"<span class="s4">.postln;<span class="Apple-converted-space"> </span></span></p>
<p class="p4"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>i.wait<span class="Apple-converted-space"> </span></p>
<p class="p4"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>}</p>
<p class="p4"><span class="Apple-tab-span">	</span>}</p>
<p class="p4"><span class="Apple-tab-span">	</span>)</p>
<p class="p5"><br></p>
<p class="p1"><b>waitUntil</b></p>
<p class="p1"><span class="Apple-tab-span">	</span>like wait, only specify a time (measured in beats of the current thread's clock)</p>
<p class="p1"><span class="Apple-tab-span">	</span>(see <a href="../Core/Kernel/Routine.html"><span class="s2">Routine</span></a>)</p>
<p class="p2"><br></p>
<p class="p1"><b>sleep</b></p>
<p class="p1"><span class="Apple-tab-span">	</span>make the current thread sleep, until woken up by re-scheduling. (see <a href="../Core/Kernel/Routine.html"><span class="s2">Routine</span></a>)</p>
<p class="p2"><span class="Apple-tab-span">	</span><span class="s6"><span class="Apple-tab-span">	</span></span></p>
<p class="p2"><br></p>
<p class="p3"><b>Binary Operations</b></p>
<p class="p2"><br></p>
<p class="p1"><b>+ aNumber</b></p>
<p class="p2"><br></p>
<p class="p1">Addition</p>
<p class="p2"><br></p>
<p class="p1"><b>- aNumber</b></p>
<p class="p2"><br></p>
<p class="p1">Subtraction</p>
<p class="p2"><br></p>
<p class="p1"><b>* aNumber</b></p>
<p class="p2"><br></p>
<p class="p1">Multiplication</p>
<p class="p2"><br></p>
<p class="p1"><b>/ aNumber</b></p>
<p class="p2"><br></p>
<p class="p1">Division</p>
<p class="p2"><br></p>
<p class="p1"><b>% aNumber</b></p>
<p class="p2"><br></p>
<p class="p1">Modulo</p>
<p class="p2"><br></p>
<p class="p1"><b>div(aNumber)</b></p>
<p class="p2"><br></p>
<p class="p1">Integer Division</p>
<p class="p2"><br></p>
<p class="p1"><b>** aNumber</b></p>
<p class="p2"><br></p>
<p class="p1">Exponentiation</p>
<p class="p2"><br></p>
<p class="p1"><b>min(aNumber)</b></p>
<p class="p2"><br></p>
<p class="p1">Minimum</p>
<p class="p2"><br></p>
<p class="p1"><b>max(aNumber)</b></p>
<p class="p2"><br></p>
<p class="p1">Maximum</p>
<p class="p2"><br></p>
<p class="p1"><b>&amp; aNumber</b></p>
<p class="p2"><br></p>
<p class="p1">Bitwise And</p>
<p class="p2"><br></p>
<p class="p1"><b>| aNumber</b></p>
<p class="p2"><br></p>
<p class="p1">Bitwise Or</p>
<p class="p2"><br></p>
<p class="p1"><b>bitXor(aNumber)</b></p>
<p class="p2"><br></p>
<p class="p1">Bitwise Exclusive Or</p>
<p class="p2"><br></p>
<p class="p1"><b>bitHammingDistance(aNumber)</b></p>
<p class="p2"><br></p>
<p class="p1">Binary Hamming distance, or the count of bits that are not the same in the two numbers</p>
<p class="p2"><br></p>
<p class="p1"><b>bitTest(aNumber)</b></p>
<p class="p2"><br></p>
<p class="p1">Returns true if bit at index aNumber is set.</p>
<p class="p2"><br></p>
<p class="p1"><b>lcm(aNumber)</b></p>
<p class="p2"><br></p>
<p class="p1">Least common multiple</p>
<p class="p2"><br></p>
<p class="p1"><b>gcd(aNumber)</b></p>
<p class="p2"><br></p>
<p class="p1">Greatest common divisor</p>
<p class="p2"><br></p>
<p class="p1"><b>round(aNumber)</b></p>
<p class="p2"><br></p>
<p class="p1">Round to multiple of aNumber</p>
<p class="p2"><br></p>
<p class="p1"><b>trunc(aNumber)</b></p>
<p class="p2"><br></p>
<p class="p1">Truncate to multiple of aNumber</p>
<p class="p2"><br></p>
<p class="p1"><b>atan2(aNumber)</b></p>
<p class="p2"><br></p>
<p class="p1">Arctangent of (this/aNumber)</p>
<p class="p2"><br></p>
<p class="p1"><b>hypot(aNumber)</b></p>
<p class="p2"><br></p>
<p class="p1">Square root of the sum of the squares.</p>
<p class="p2"><br></p>
<p class="p1"><b>&lt;&lt; aNumber</b></p>
<p class="p2"><br></p>
<p class="p1">Binary shift left.</p>
<p class="p2"><br></p>
<p class="p1"><b>&gt;&gt; aNumber</b></p>
<p class="p2"><br></p>
<p class="p1">Binary shift right.</p>
<p class="p2"><br></p>
<p class="p1"><b>+&gt;&gt; aNumber</b></p>
<p class="p2"><br></p>
<p class="p1">Unsigned binary shift right.</p>
<p class="p2"><br></p>
<p class="p1"><b>fill(aNumber)</b></p>
<p class="p2"><br></p>
<p class="p1"><b>ring1(aNumber)</b></p>
<p class="p2"><br></p>
<p class="p1">(a * b) + a</p>
<p class="p2"><br></p>
<p class="p1"><b>ring2(aNumber)</b></p>
<p class="p2"><br></p>
<p class="p1">((a*b) + a + b)</p>
<p class="p2"><br></p>
<p class="p1"><b>ring3(aNumber)</b></p>
<p class="p2"><br></p>
<p class="p1">(a*a *b)</p>
<p class="p2"><br></p>
<p class="p1"><b>ring4(aNumber)</b></p>
<p class="p2"><br></p>
<p class="p1">((a*a *b) - (a*b*b))</p>
<p class="p2"><br></p>
<p class="p1"><b>difsqr(aNumber)</b></p>
<p class="p2"><br></p>
<p class="p1">(a*a) - (b*b)</p>
<p class="p2"><br></p>
<p class="p1"><b>sumsqr(aNumber)</b></p>
<p class="p2"><br></p>
<p class="p1">(a*a) + (b*b)</p>
<p class="p2"><br></p>
<p class="p1"><b>sqrdif(aNumber)</b></p>
<p class="p2"><br></p>
<p class="p1">(a - b)**2</p>
<p class="p2"><br></p>
<p class="p1"><b>sqrsum(aNumber)</b></p>
<p class="p2"><br></p>
<p class="p1">(a + b)**2</p>
<p class="p2"><br></p>
<p class="p1"><b>absdif(aNumber)</b></p>
<p class="p2"><br></p>
<p class="p1">(a - b).abs</p>
<p class="p2"><br></p>
<p class="p1"><b>amclip(aNumber)</b></p>
<p class="p2"><br></p>
<p class="p1">0<span class="Apple-converted-space">  </span>when<span class="Apple-converted-space">  </span>b &lt;= 0,<span class="Apple-converted-space">  </span>a*b<span class="Apple-converted-space">  </span>when<span class="Apple-converted-space">  </span>b &gt; 0</p>
<p class="p2"><br></p>
<p class="p1"><b>scaleneg(aNumber)</b></p>
<p class="p2"><br></p>
<p class="p1">a*b when a &lt; 0, otherwise a.</p>
<p class="p2"><br></p>
<p class="p1"><b>clip2(aNumber)</b></p>
<p class="p2"><br></p>
<p class="p1">clips receiver to +/- aNumber</p>
<p class="p2"><br></p>
<p class="p1"><b>excess(aNumber)</b></p>
<p class="p2"><br></p>
<p class="p1">Returns the difference of the receiver and its clipped form: (a - clip2(a,b)).</p>
<p class="p2"><br></p>
<p class="p1"><b>&lt;! aNumber</b></p>
<p class="p2"><br></p>
<p class="p1">Return the receiver. aNumber is ignored.</p>
<p class="p2"><br></p>
<p class="p1"><b>asFraction(denominator, fasterBetter)</b></p>
<p class="p2"><br></p>
<p class="p1">Return an array of denominator and divisor of the nearest and smallest fraction</p>
<p class="p2"><br></p>
<p class="p1"><b>rrand(aNumber)</b></p>
<p class="p2"><br></p>
<p class="p1">Returns a random number in the interval ]a, b[. If both a and b are Integer then the result will be an Integer.</p>
<p class="p2"><br></p>
<p class="p1"><b>exprand(aNumber)</b></p>
<p class="p2"><br></p>
<p class="p1">Returns an exponentially distributed random number in the interval ]a, b[. Always returns a Float.</p>
<p class="p2"><br></p>
<p class="p1"><b>gauss(standardDeviation)</b></p>
<p class="p2"><br></p>
<p class="p1">Returns a gaussian distributed random number. Always returns a Float.</p>
<p class="p2"><span class="Apple-tab-span">	</span></p>
<p class="p4">(0..1000).collect { |num| gauss(0.0, num) }.plot;</p>
<p class="p2"><br></p>
<p class="p2"><br></p>
<p class="p1"><b>nextTimeOnGrid(clock)</b></p>
<p class="p2"><br></p>
<p class="p1">Return the next possible multiple of the clock's beats.</p>
<p class="p2"><br></p>
<p class="p2"><br></p>
<p class="p2"><br></p>
<p class="p3"><b>N-ary Operations</b></p>
<p class="p2"><br></p>
<p class="p2"><br></p>
<p class="p1"><b>degreeToKey(scale, stepsPerOctave)</b></p>
<p class="p2"><br></p>
<p class="p1"><span class="Apple-tab-span">	</span>the value is truncated to an integer and used as an index into an octave repeating table of note values.</p>
<p class="p1"><span class="Apple-tab-span">	</span>Indices wrap around the table and shift octaves as they do</p>
<p class="p1"><span class="Apple-tab-span">	</span>stepsPerOctave is 12 by default</p>
<p class="p2"><span class="Apple-tab-span">	</span></p>
<p class="p4"><span class="s7"><span class="Apple-tab-span">	</span></span>(</p>
<p class="p4"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>l = [0, 1, 5, 9, 11]; <span class="s8">// pentatonic scale</span></p>
<p class="p4"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>(1, 2..15).collect { <span class="s2">|i|</span> i.degreeToKey(l, 12) }</p>
<p class="p4"><span class="Apple-tab-span">	</span>)</p>
<p class="p2"><br></p>
<p class="p2"><br></p>
<p class="p1"><b>keyToDegree(scale, stepsPerOctave)</b></p>
<p class="p2"><br></p>
<p class="p1"><span class="Apple-tab-span">	</span>inverse of degreeToKey.</p>
<p class="p1"><span class="Apple-tab-span">	</span>stepsPerOctave is 12 by default</p>
<p class="p2"><span class="Apple-tab-span">	</span></p>
<p class="p4"><span class="s7"><span class="Apple-tab-span">	</span></span>(</p>
<p class="p4"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>l = [0, 1, 5, 9, 11]; <span class="s8">// pentatonic scale</span></p>
<p class="p4"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>(60, 61..75).collect { <span class="s2">|i|</span> i.keyToDegree(l, 12) }</p>
<p class="p4"><span class="Apple-tab-span">	</span>)</p>
<p class="p4"><span class="Apple-tab-span">	</span>(</p>
<p class="p4"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>l = [0, 1, 5, 9, 11]; <span class="s8">// pentatonic scale</span></p>
<p class="p4"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>(60, 61..75).postln.collect { <span class="s2">|i|</span> i.keyToDegree(l, 12).degreeToKey(l) }</p>
<p class="p4"><span class="Apple-tab-span">	</span>)</p>
<p class="p5"><span class="Apple-tab-span">	</span></p>
<p class="p1"><b>nearestInList(list)</b></p>
<p class="p2"><br></p>
<p class="p1"><span class="Apple-tab-span">	</span>returns the value in the collection closest to this</p>
<p class="p2"><span class="Apple-tab-span">	</span></p>
<p class="p4"><span class="s7"><span class="Apple-tab-span">	</span></span>(</p>
<p class="p4"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>l = [0, 0.5, 0.9, 1];</p>
<p class="p4"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>(0, 0.05..1).collect { |i| i.nearestInList(l) }</p>
<p class="p4"><span class="Apple-tab-span">	</span>)</p>
<p class="p2"><br></p>
<p class="p2"><br></p>
<p class="p1"><b>nearestInScale(scale, stepsPerOctave)</b></p>
<p class="p2"><br></p>
<p class="p1"><span class="Apple-tab-span">	</span>returns the value in the collection closest to this, assuming an octave repeating table of note values.</p>
<p class="p1"><span class="Apple-tab-span">	</span>stepsPerOctave is 12 by default</p>
<p class="p2"><span class="Apple-tab-span">	</span></p>
<p class="p4"><span class="s7"><span class="Apple-tab-span">	</span></span>(</p>
<p class="p4"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>l = [0, 1, 5, 9, 11]; <span class="s8">// pentatonic scale</span></p>
<p class="p4"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>(60, 61..76).collect { |i| i.nearestInScale(l, 12) }</p>
<p class="p4"><span class="Apple-tab-span">	</span>)</p>
<p class="p2"><span class="Apple-tab-span">	</span></p>
<p class="p1"><b>partition(parts, min)</b></p>
<p class="p2"><br></p>
<p class="p1"><span class="Apple-tab-span">	</span>randomly partition a number into parts of at least min size.</p>
<p class="p2"><br></p>
<p class="p4"><span class="s7"><span class="Apple-tab-span">	</span></span>75.partition(8, 3);</p>
<p class="p4"><span class="Apple-tab-span">	</span>75.partition(75, 1);</p>
<p class="p2"><br></p>
<p class="p2"><br></p>
<p class="p1"><b>asTimeString(precision, maxDays = 365, dropDaysIfPossible = true)</b></p>
<p class="p2"><br></p>
<p class="p1"><span class="Apple-tab-span">	</span>returns a string corresponding to the days:hours:minutes:seconds<span class="Apple-converted-space"> </span></p>
<p class="p1"><span class="Apple-tab-span">	</span>based on the receiver as number of seconds.</p>
<p class="p1"><span class="Apple-tab-span">	</span><b>precision</b> is 0.001 (ms) by default</p>
<p class="p1"><span class="Apple-tab-span">	</span>this format is inspired by ISO 8601 time interval display (truncated representation)</p>
<p class="p1"><span class="Apple-tab-span">	</span>returns string "ddd:hh:mm:ss:ttt" where t is milliseconds</p>
<p class="p1"><span class="Apple-tab-span">	</span>see <a href="../Collections/String.html"><span class="s9">String</span></a>:asSecs for complement</p>
<p class="p2"><span class="Apple-tab-span">	</span></p>
<p class="p4"><span class="s7"><span class="Apple-tab-span">	</span></span>(</p>
<p class="p4"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="s2">var</span> start = <span class="s2">Main</span>.elapsedTime;</p>
<p class="p4"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>fork { loop { (<span class="s2">Main</span>.elapsedTime - start).asTimeString.postln; 0.05.wait } };</p>
<p class="p4"><span class="Apple-tab-span">	</span>)</p>
<p class="p5"><br></p>
<p class="p1"><b>equalWithPrecision(that, precision)</b></p>
<p class="p2"><br></p>
<p class="p1"><span class="Apple-tab-span">	</span>return true if receiver is closer to <b>that</b> than <b>precision</b>. (default for precision: 0.0001)</p>
<p class="p2"><span class="Apple-tab-span">	</span></p>
<p class="p4"><span class="s7"><span class="Apple-tab-span">	</span></span>3.1.equalWithPrecision(3.0, 0.05); <span class="s8">// false</span></p>
<p class="p4"><span class="Apple-tab-span">	</span>3.1.equalWithPrecision(3.0, 0.1); <span class="s8">// false</span></p>
<p class="p4"><span class="Apple-tab-span">	</span>3.1.equalWithPrecision(3.0, 0.11); <span class="s8">// true</span></p>
<p class="p5"><br></p>
<p class="p5"><span class="Apple-tab-span">	</span></p>
<p class="p1"><b>quantize(quantum, tolerance, strength)</b></p>
<p class="p2"><b><span class="Apple-tab-span">	</span></b></p>
<p class="p1"><b><span class="Apple-tab-span">	</span></b>round the receiver to the <b>quantum</b> (default: 1.0) allowing for a <b>tolerance</b> (default: 0.05).</p>
<p class="p1"><span class="Apple-tab-span">	</span>How much the value is allowed to differ in the tolerance range is determined by <b>strength</b> (default: 1.0).</p>
<p class="p2"><br></p>
<p class="p4"><span class="Apple-tab-span">	</span>((0..10) / 10).collect { <span class="s2">|num|</span> num.quantize(1, 0.3, 0.5) }.postcs.plot;</p>
<p class="p4"><span class="Apple-tab-span">	</span>((0..10) / 10).collect { <span class="s2">|num|</span> num.quantize(1, 0.6, 0.5) }.postcs.plot;</p>
<p class="p4"><span class="Apple-tab-span">	</span>((0..10) / 10).collect { <span class="s2">|num|</span> num.quantize(1, 1.0, 0.5) }.postcs.plot;</p>
<p class="p2"><br></p>
<p class="p2"><br></p>
<p class="p1"><b>linlin(inMin, inMax, outMin, outMax, clip)</b></p>
<p class="p5"><br></p>
<p class="p1"><span class="s6"><span class="Apple-tab-span">	</span></span>map the receiver from an assumed linear input range (inMin..inMax)</p>
<p class="p1"><span class="Apple-tab-span">	</span>to a linear output range (outMin..outMax). If the input exceeds the assumed input range.<span class="Apple-converted-space"> </span></p>
<p class="p1"><span class="Apple-tab-span">	</span>If the input exceeds the input range, the following behaviours are specified by the <b>clip</b> argument:<span class="Apple-converted-space"> </span></p>
<p class="p1"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><b>nil</b> (don't clip), <b>\max</b> (clip ceiling), <b>\min</b>, (clip floor), <b>\minmax</b> (clip both - this is default).</p>
<p class="p2"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span></p>
<p class="p4"><span class="Apple-tab-span">	</span>(0..10).collect { <span class="s2">|num|</span> num.linlin(0, 10, -4.3, 100) };<span class="Apple-converted-space"> </span></p>
<p class="p4"><span class="Apple-tab-span">	</span>(0..10).linlin(0, 10, -4.3, 100); <span class="s8">// equivalent.</span></p>
<p class="p5"><br></p>
<p class="p2"><br></p>
<p class="p1"><b>linexp(inMin, inMax, outMin, outMax, clip)</b></p>
<p class="p5"><br></p>
<p class="p1"><span class="s6"><span class="Apple-tab-span">	</span></span>map the receiver from an assumed linear input range (inMin..inMax)</p>
<p class="p1"><span class="Apple-tab-span">	</span>to an exponential output range (outMin..outMax).</p>
<p class="p1"><span class="Apple-tab-span">	</span>The output range must not include zero.<span class="Apple-converted-space"> </span></p>
<p class="p1"><span class="Apple-tab-span">	</span>If the input exceeds the input range, the following behaviours are specified by the <b>clip</b> argument:<span class="Apple-converted-space"> </span></p>
<p class="p1"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><b>nil</b> (don't clip), <b>\max</b> (clip ceiling), <b>\min</b>, (clip floor), <b>\minmax</b> (clip both - this is default).</p>
<p class="p2"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span></p>
<p class="p4"><span class="s7"><span class="Apple-tab-span">	</span></span>(0..10).collect { <span class="s2">|num|</span> num.linexp(0, 10, 4.3, 100) };<span class="Apple-converted-space"> </span></p>
<p class="p4"><span class="Apple-tab-span">	</span>(0..10).linexp(0, 10, 4.3, 100); <span class="s8">// equivalent.</span></p>
<p class="p2"><b><span class="Apple-tab-span">	</span></b></p>
<p class="p1"><b>explin(inMin, inMax, outMin, outMax, clip)</b></p>
<p class="p5"><br></p>
<p class="p1"><span class="s6"><span class="Apple-tab-span">	</span></span>map the receiver from an assumed exponential input range (inMin..inMax)</p>
<p class="p1"><span class="Apple-tab-span">	</span>to a linear output range (outMin..outMax). If the input exceeds the assumed input range.</p>
<p class="p1"><span class="Apple-tab-span">	</span>The input range must not include zero.<span class="Apple-converted-space"> </span></p>
<p class="p1"><span class="Apple-tab-span">	</span>If the input exceeds the input range, the following behaviours are specified by the <b>clip</b> argument:<span class="Apple-converted-space"> </span></p>
<p class="p1"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><b>nil</b> (don't clip), <b>\max</b> (clip ceiling), <b>\min</b>, (clip floor), <b>\minmax</b> (clip both - this is default).<span class="s6"><span class="Apple-tab-span">	</span></span></p>
<p class="p5"><br></p>
<p class="p4"><span class="Apple-tab-span">	</span>(1..10).collect { <span class="s2">|num|</span> num.explin(0.1, 10, -4.3, 100) };<span class="Apple-converted-space"> </span></p>
<p class="p4"><span class="Apple-tab-span">	</span>(1..10).explin(0.1, 10, -4.3, 100); <span class="s8">// equivalent.</span></p>
<p class="p8"><span class="Apple-tab-span">	</span></p>
<p class="p5"><br></p>
<p class="p1"><b>expexp(inMin, inMax, outMin, outMax, clip)</b></p>
<p class="p5"><br></p>
<p class="p1"><span class="s6"><span class="Apple-tab-span">	</span></span>map the receiver from an assumed exponential input range (inMin..inMax)</p>
<p class="p1"><span class="Apple-tab-span">	</span>to an exponential output range (outMin..outMax). If the input exceeds the assumed input range.</p>
<p class="p1"><span class="Apple-tab-span">	</span>Both input range and output range must not include zero.<span class="Apple-converted-space"> </span></p>
<p class="p1"><span class="Apple-tab-span">	</span>If the input exceeds the input range, the following behaviours are specified by the <b>clip</b> argument:<span class="Apple-converted-space"> </span></p>
<p class="p1"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><b>nil</b> (don't clip), <b>\max</b> (clip ceiling), <b>\min</b>, (clip floor), <b>\minmax</b> (clip both - this is default).</p>
<p class="p2"><br></p>
<p class="p4"><span class="Apple-tab-span">	</span>(1..10).collect { <span class="s2">|num|</span> num.expexp(0.1, 10, 4.3, 100) };<span class="Apple-converted-space"> </span></p>
<p class="p4"><span class="Apple-tab-span">	</span>(1..10).expexp(0.1, 10, 4.3, 100); <span class="s8">// equivalent.</span></p>
<p class="p8"><span class="Apple-tab-span">	</span></p>
<p class="p1"><b>lincurve(inMin, inMax, outMin, outMax, curve, clip)</b></p>
<p class="p5"><br></p>
<p class="p1"><span class="s6"><span class="Apple-tab-span">	</span></span>map the receiver from an assumed linear input range (inMin..inMax)</p>
<p class="p1"><span class="Apple-tab-span">	</span>to an exponential curve output range (outMin..outMax). A <b>curve</b> is like the curve parameter in <a href="../Control/Env.html"><span class="s10">Env</span></a></p>
<p class="p1"><span class="Apple-tab-span">	</span>Unlike with linexp, the output range may include zero.<span class="Apple-converted-space"> </span></p>
<p class="p1"><span class="Apple-tab-span">	</span>If the input exceeds the input range, the following behaviours are specified by the <b>clip</b> argument:<span class="Apple-converted-space"> </span></p>
<p class="p1"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><b>nil</b> (don't clip), <b>\max</b> (clip ceiling), <b>\min</b>, (clip floor), <b>\minmax</b> (clip both - this is default).</p>
<p class="p2"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span></p>
<p class="p4"><span class="s7"><span class="Apple-tab-span">	</span></span>(0..10).collect { <span class="s11">|num|</span> num.lincurve(0, 10, -4.3, 100, -3) };<span class="Apple-converted-space"> </span></p>
<p class="p4"><span class="Apple-tab-span">	</span>(0..10).lincurve(0, 10, -4.3, 100, -3); <span class="s8">// equivalent.</span></p>
<p class="p9"><span class="s8"><span class="Apple-tab-span">	</span></span>// different curves:</p>
<p class="p4"><span class="Apple-tab-span">	</span>(</p>
<p class="p4"><span class="Apple-tab-span">	</span>(-4..4).do { <span class="s12">|val|</span></p>
<p class="p4"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>(0..100).collect(<span class="s12">_</span>.lincurve(0, 100, 0, 1, val)).plot</p>
<p class="p4"><span class="Apple-tab-span">	</span>}</p>
<p class="p4"><span class="Apple-tab-span">	</span>)</p>
<p class="p8"><span class="Apple-tab-span">	</span></p>
<p class="p8"><span class="Apple-tab-span">	</span></p>
<p class="p1"><b>curvelin(inMin, inMax, outMin, outMax, curve, clip)</b></p>
<p class="p5"><br></p>
<p class="p1"><span class="s6"><span class="Apple-tab-span">	</span></span>map the receiver from an assumed curve-exponential input range (inMin..inMax)</p>
<p class="p1"><span class="Apple-tab-span">	</span>to a linear output range (outMin..outMax). If the input exceeds the assumed input range.</p>
<p class="p1"><span class="Apple-tab-span">	</span>A<b> curve</b> is<span class="Apple-converted-space">  </span>like the curve parameter in <a href="../Control/Env.html"><span class="s10">Env</span></a><span class="s10">.</span></p>
<p class="p1"><span class="Apple-tab-span">	</span>Unlike with explin, the input range may include zero.<span class="Apple-converted-space"> </span></p>
<p class="p1"><span class="Apple-tab-span">	</span>If the input exceeds the input range, the following behaviours are specified by the <b>clip</b> argument:<span class="Apple-converted-space"> </span></p>
<p class="p1"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><b>nil</b> (don't clip), <b>\max</b> (clip ceiling), <b>\min</b>, (clip floor), <b>\minmax</b> (clip both - this is default).<span class="s6"><span class="Apple-tab-span">	</span></span></p>
<p class="p5"><br></p>
<p class="p4"><span class="Apple-tab-span">	</span>(1..10).collect { <span class="s11">|num|</span> num.curvelin(0, 10, -4.3, 100, -3) };<span class="Apple-converted-space"> </span></p>
<p class="p4"><span class="Apple-tab-span">	</span>(1..10).curvelin(0, 10, -4.3, 100, -3); <span class="s8">// equivalent.</span></p>
<p class="p9"><span class="s8"><span class="Apple-tab-span">	</span></span>// different curves:</p>
<p class="p4"><span class="Apple-tab-span">	</span>(</p>
<p class="p4"><span class="Apple-tab-span">	</span>(-4..4).do { <span class="s13">|val|</span></p>
<p class="p4"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>(0..100).collect(<span class="s13">_</span>.curvelin(0, 100, 0, 1, val)).plot</p>
<p class="p4"><span class="Apple-tab-span">	</span>}</p>
<p class="p4"><span class="Apple-tab-span">	</span>)</p>
<p class="p8"><br></p>
<p class="p8"><span class="Apple-tab-span">	</span></p>
<p class="p1"><b>bilin(inCenter, inMin, inMax, outCenter, outMin, outMax, clip)</b></p>
<p class="p5"><br></p>
<p class="p1"><span class="s6"><span class="Apple-tab-span">	</span></span>map the receiver from two assumed linear input ranges (inMin..inCenter) and (inCenter..inMax)</p>
<p class="p1"><span class="Apple-tab-span">	</span>to two linear output ranges (outMin..outCenter) and (outCenter..outMax).</p>
<p class="p1"><span class="Apple-tab-span">	</span>If the input exceeds the input range, the following behaviours are specified by the <b>clip</b> argument:<span class="Apple-converted-space"> </span></p>
<p class="p1"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><b>nil</b> (don't clip), <b>\max</b> (clip ceiling), <b>\min</b>, (clip floor), <b>\minmax</b> (clip both - this is default).</p>
<p class="p2"><br></p>
<p class="p2"><br></p>
<p class="p4"><span class="s7"><span class="Apple-tab-span">	</span></span>(</p>
<p class="p4"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>var center = 0.5, ctlCenter;</p>
<p class="p4"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>w = <span class="s2">Window</span>("bilin", Rect(100, 100, 200, 100)).front;</p>
<p class="p4"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>a = <span class="s2">Slider</span>(w, <span class="s2">Rect</span>(20, 20, 150, 20)).value_(0.5);</p>
<p class="p4"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>b = <span class="s2">Slider</span>(w, <span class="s2">Rect</span>(20, 45, 150, 20)).value_(0.5);</p>
<p class="p4"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>b.action = { center = b.value };</p>
<p class="p4"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>a.mouseDownAction = { ctlCenter = a.value };</p>
<p class="p4"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>a.action = {<span class="Apple-converted-space"> </span></p>
<p class="p4"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>b.value = a.value.bilin(ctlCenter, 0, 1, center, 0, 1);</p>
<p class="p4"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>};</p>
<p class="p4"><span class="Apple-tab-span">	</span>)</p>
<p class="p2"><br></p>
<p class="p1"><b>biexp(inCenter, inMin, inMax, outCenter, outMin, outMax, clip)</b></p>
<p class="p5"><br></p>
<p class="p1"><span class="s6"><span class="Apple-tab-span">	</span></span>map the receiver from two assumed exponential input ranges (inMin..inCenter) and (inCenter..inMax)</p>
<p class="p1"><span class="Apple-tab-span">	</span>to two linear output ranges (outMin..outCenter) and (outCenter..outMax).</p>
<p class="p1"><span class="Apple-tab-span">	</span>The input range must not include zero.<span class="Apple-converted-space"> </span></p>
<p class="p1"><span class="Apple-tab-span">	</span>If the input exceeds the input range, the following behaviours are specified by the <b>clip</b> argument:<span class="Apple-converted-space"> </span></p>
<p class="p1"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><b>nil</b> (don't clip), <b>\max</b> (clip ceiling), <b>\min</b>, (clip floor), <b>\minmax</b> (clip both - this is default).<span class="Apple-tab-span">	</span></p>
<p class="p2"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span></p>
<p class="p6"><span class="s14"><span class="Apple-tab-span">	</span></span>// doesn't properly work yet.</p>
<p class="p4"><span class="Apple-tab-span">	</span>(</p>
<p class="p4"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="s2">var</span> center = 0.5, ctlCenter;</p>
<p class="p4"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>w = <span class="s2">Window</span>(<span class="s5">"biexp"</span>, <span class="s2">Rect</span>(100, 100, 200, 100)).front;</p>
<p class="p4"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>a = <span class="s2">Slider</span>(w, <span class="s2">Rect</span>(20, 20, 150, 20)).value_(0.5);</p>
<p class="p4"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>b = <span class="s2">Slider</span>(w, <span class="s2">Rect</span>(20, 45, 150, 20)).value_(0.5);</p>
<p class="p4"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>b.action = { center = b.value };</p>
<p class="p4"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>a.mouseDownAction = { ctlCenter = a.value + 0.05 };</p>
<p class="p4"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>a.action = {</p>
<p class="p4"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>b.value = (a.value + 0.1).biexp(ctlCenter, 0.1, 1.1, center, 0, 1);</p>
<p class="p4"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>};</p>
<p class="p4"><span class="Apple-tab-span">	</span>)</p>
<p class="p5"><span class="Apple-tab-span">	</span></p>
<p class="p1"><b>lcurve(a, m, n, tau)</b></p>
<p class="p2"><br></p>
<p class="p1"><span class="Apple-tab-span">	</span>map the receiver onto an L-curve, using the formula: a * (m * exp(x) * rTau + 1) / (n * exp(x) * rTau + 1).</p>
<p class="p1"><span class="Apple-tab-span">	</span>This is used for smoothing values and limiting them to a range. Defalt values: <b>a = 1; m = 0; tau = 1</b>.</p>
<p class="p5"><span class="Apple-tab-span">	</span></p>
<p class="p4"><span class="Apple-tab-span">	</span>(0..1000).normalize(-10, 10).collect { <span class="s2">|num|</span> num.lcurve }.plot;<span class="s7"><span class="Apple-tab-span">	</span></span></p>
<p class="p2"><span class="Apple-tab-span">	</span></p>
<p class="p5"><br></p>
<p class="p1"><b>gaussCurve(a, b, c)</b></p>
<p class="p2"><br></p>
<p class="p1"><span class="Apple-tab-span">	</span>map the receiver onto a gauss function, using the formula: a * (exp(squared(this - b) / (-2.0 * squared(c))))<span class="Apple-tab-span">	</span>Defalt values: <b>a = 1; b = 0; c = 1</b></p>
<p class="p5"><span class="Apple-tab-span">	</span></p>
<p class="p4"><span class="Apple-tab-span">	</span>(0..1000).normalize(-10, 10).collect { <span class="s2">|num|</span> num.gaussCurve }.plot;</p>
<p class="p5"><span class="Apple-tab-span">	</span></p>
<p class="p5"><span class="Apple-tab-span">	</span></p>
<p class="p1"><b>series(second, last)</b></p>
<p class="p2"><br></p>
<p class="p1"><span class="Apple-tab-span">	</span>return an artithmetic series from <b>this</b> over <b>second</b> to <b>last</b>. This is used in the shortcuts:</p>
<p class="p1"><span class="Apple-tab-span">	</span>(0..100) or (1, 3 .. 17). if <b>second</b> is nil, it is one magnitude step towards last (1 or -1).</p>
<p class="p5"><span class="Apple-tab-span">	</span></p>
<p class="p4"><span class="Apple-tab-span">	</span>series(5, 7, 10);</p>
<p class="p4"><span class="Apple-tab-span">	</span>series(5, nil, 10);</p>
<p class="p4"><span class="Apple-tab-span">	</span>(5, 7 .. 10)<span class="Apple-tab-span">	</span></p>
<p class="p5"><span class="Apple-tab-span">	</span></p>
<p class="p5"><span class="Apple-tab-span">	</span></p>
<p class="p1"><b>seriesIter(second, last)</b></p>
<p class="p2"><br></p>
<p class="p1"><span class="Apple-tab-span">	</span>return a <a href="../Core/Kernel/Routine.html"><span class="s2">Routine</span></a> that iterates over the numbers from <b>this</b> to <b>last</b>.<span class="Apple-converted-space"> </span></p>
<p class="p1"><span class="Apple-tab-span">	</span>Since this is a lazy operation, <b>last</b> may be <b>inf</b>, generating an endless series<span class="Apple-converted-space"> </span></p>
<p class="p10"><span class="s4"><span class="Apple-tab-span">	</span>(see also: <a href="../Language/ListComprehensions.html"><span class="s7">ListComprehensions</span></a>)</span></p>
<p class="p5"><span class="Apple-tab-span">	</span></p>
<p class="p4"><span class="Apple-tab-span">	</span>r = seriesIter(0, 5);</p>
<p class="p4"><span class="Apple-tab-span">	</span>r.nextN(8);<span class="Apple-tab-span">	</span></p>
<p class="p4"><span class="Apple-tab-span">	</span>r.nextN(8);<span class="Apple-tab-span">	</span></p>
<p class="p5"><br></p>
</body>
</html>
