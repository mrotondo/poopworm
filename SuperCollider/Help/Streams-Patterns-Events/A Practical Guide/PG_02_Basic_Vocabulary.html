<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta http-equiv="Content-Style-Type" content="text/css">
<title></title>
<meta name="Generator" content="Cocoa HTML Writer">
<meta name="CocoaVersion" content="824.48">
<style type="text/css">
p.p1 {margin: 0.0px 0.0px 0.0px 0.0px; font: 18.0px Helvetica}
p.p2 {margin: 0.0px 0.0px 0.0px 0.0px; font: 12.0px Helvetica; min-height: 14.0px}
p.p3 {margin: 0.0px 0.0px 0.0px 0.0px; font: 12.0px Helvetica}
p.p4 {margin: 0.0px 0.0px 0.0px 0.0px; font: 16.0px Helvetica}
p.p5 {margin: 0.0px 0.0px 0.0px 0.0px; font: 14.0px Helvetica}
p.p6 {margin: 0.0px 0.0px 0.0px 0.0px; font: 9.0px Monaco; color: #bf0000}
p.p7 {margin: 0.0px 0.0px 0.0px 0.0px; font: 9.0px Monaco}
p.p8 {margin: 0.0px 0.0px 0.0px 0.0px; font: 9.0px Monaco; color: #000000}
p.p9 {margin: 0.0px 0.0px 0.0px 0.0px; font: 9.0px Monaco; color: #000000; min-height: 12.0px}
p.p10 {margin: 0.0px 0.0px 0.0px 0.0px; font: 9.0px Monaco; min-height: 12.0px}
p.p11 {margin: 0.0px 0.0px 0.0px 0.0px; font: 9.0px Monaco; color: #007300}
p.p12 {margin: 0.0px 0.0px 0.0px 0.0px; font: 9.0px Monaco; color: #0000bf}
p.p13 {margin: 0.0px 0.0px 0.0px 0.0px; font: 9.0px Monaco; color: #bf0000}
p.p14 {margin: 0.0px 0.0px 0.0px 0.0px; font: 12.0px Helvetica; color: #0000bf}
span.s1 {color: #bf0000}
span.s2 {color: #0000bf}
span.s3 {color: #000000}
span.s4 {text-decoration: underline ; color: #0000bf}
span.s5 {color: #0000bf}
span.s6 {color: #007300}
span.s7 {font: 12.0px Helvetica}
span.Apple-tab-span {white-space:pre}
</style>
</head>
<body>
<p class="p1"><b>Basic Vocabulary: Generating values</b></p>
<p class="p2"><br></p>
<p class="p3">Before getting to the really cool things patterns can do, we need to build up a basic vocabulary. We'll start with some words, then move into phrases in the next tutorial.</p>
<p class="p2"><br></p>
<p class="p3">Some of the patterns will be demonstrated with a Pbind construct. This is a taste of things to come -- sequencing sonic events using patterns. Don't worry about how Pbind works just yet... all in good time.</p>
<p class="p2"><br></p>
<p class="p3">Let's start with a very quick reference of some basic patterns. More complete descriptions follow this list. The list might seem long at first, but concentrate your attention on patterns marked with a star. Those are the most basic, and commonly used. Again, the purpose is to start learning the vocabulary of patterns -- like learning new words when studying a human language.</p>
<p class="p2"><br></p>
<p class="p3">This document describes a lot of patterns, but what I call "primary patterns" are the most important. If you are new to patterns, concentrate on these first. You can always come back and look at the rest later.</p>
<p class="p2"><br></p>
<p class="p3">For more information on any of these patterns, select the class name and use the help key for your editor to open its help file.</p>
<p class="p2"><br></p>
<p class="p2"><br></p>
<p class="p4"><b>Quick reference</b></p>
<p class="p2"><br></p>
<p class="p3"><b>Primary Patterns</b></p>
<p class="p2"><br></p>
<ul>
<li style="margin: 0.0px 0.0px 0.0px 0.0px; font: 12.0px Helvetica"><span class="s1"><b>* </b></span><b>Pseq(list, repeats, offset):</b> Play through the entire list 'repeats' times. Like list.do.</li>
<li style="margin: 0.0px 0.0px 0.0px 0.0px; font: 12.0px Helvetica"><span class="s1"><b>* </b></span><b>Prand(list, repeats):</b> Choose items from the list randomly (same as list.choose).</li>
<li style="margin: 0.0px 0.0px 0.0px 0.0px; font: 12.0px Helvetica"><span class="s1"><b>* </b></span><b>Pxrand(list, repeats):</b> Choose randomly, but never repeat the same item twice.</li>
<li style="margin: 0.0px 0.0px 0.0px 0.0px; font: 12.0px Helvetica"><span class="s1"><b>* </b></span><b>Pshuf(list, repeats):</b> Shuffle the list in random order, and use the same random order 'repeats' times. Like list.scramble.</li>
<li style="margin: 0.0px 0.0px 0.0px 0.0px; font: 12.0px Helvetica"><span class="s1"><b>* </b></span><b>Pwrand(list, weights, repeats):</b> Choose randomly by weighted probabilities (like list.wchoose(weights)).</li>
</ul>
<p class="p2"><br></p>
<ul>
<li style="margin: 0.0px 0.0px 0.0px 0.0px; font: 12.0px Helvetica"><span class="s1"><b>* </b></span><b>Pseries(start, step, length):</b> Arithmetic series (addition).</li>
<li style="margin: 0.0px 0.0px 0.0px 0.0px; font: 12.0px Helvetica"><span class="s1"><b>* </b></span><b>Pgeom(start, grow, length):</b> Geometric series (multiplication).</li>
</ul>
<p class="p2"><br></p>
<ul>
<li style="margin: 0.0px 0.0px 0.0px 0.0px; font: 12.0px Helvetica"><span class="s1"><b>* </b></span><b>Pwhite(lo, hi, length):</b> Random numbers, equal distribution ("white noise"). Like rrand(lo, hi).</li>
<li style="margin: 0.0px 0.0px 0.0px 0.0px; font: 12.0px Helvetica"><span class="s1"><b>* </b></span><b>Pexprand(lo, hi, length):</b> Random numbers, exponential distribution. Like exprand(lo, hi).</li>
<li style="margin: 0.0px 0.0px 0.0px 0.0px; font: 12.0px Helvetica"><span class="s1"><b>* </b></span><b>Pbrown(lo, hi, step, length):</b> Brownian motion, arithmetic scale (addition).</li>
</ul>
<p class="p2"><br></p>
<ul>
<li style="margin: 0.0px 0.0px 0.0px 0.0px; font: 12.0px Helvetica"><span class="s1"><b>* </b></span><b>Pfunc(nextFunc, resetFunc):</b> Get the stream values from a user-supplied function.</li>
<li style="margin: 0.0px 0.0px 0.0px 0.0px; font: 12.0px Helvetica"><span class="s1"><b>* </b></span><b>Pfuncn(func, repeats):</b> Get values from the function, but stop after 'repeats' items.</li>
<li style="margin: 0.0px 0.0px 0.0px 0.0px; font: 12.0px Helvetica"><span class="s1"><b>* </b></span><b>Proutine(routineFunc):</b> Use the function like a routine. The function should return values using .yield or .embedInStream.</li>
</ul>
<p class="p2"><br></p>
<p class="p2"><br></p>
<p class="p3"><b>Additional List Patterns</b></p>
<p class="p2"><br></p>
<ul>
<li style="margin: 0.0px 0.0px 0.0px 0.0px; font: 12.0px Helvetica"><b>Pser(list, repeats, offset):</b> Play through the list as many times as needed, but output only 'repeats' items.</li>
<li style="margin: 0.0px 0.0px 0.0px 0.0px; font: 12.0px Helvetica"><b>Pslide(list, repeats, len, step, start, wrapAtEnd):</b> Play overlapping segments from the list.</li>
</ul>
<p class="p2"><br></p>
<ul>
<li style="margin: 0.0px 0.0px 0.0px 0.0px; font: 12.0px Helvetica"><b>Pwalk(list, stepPattern, directionPattern, startPos):</b> Random walk over the list.</li>
</ul>
<p class="p2"><br></p>
<ul>
<li style="margin: 0.0px 0.0px 0.0px 0.0px; font: 12.0px Helvetica"><b>Place(list, repeats, offset):</b> Interlace any arrays found in the main list.</li>
<li style="margin: 0.0px 0.0px 0.0px 0.0px; font: 12.0px Helvetica"><b>Ppatlace(list, repeats, offset):</b> Interlace any patterns found in the main list.</li>
<li style="margin: 0.0px 0.0px 0.0px 0.0px; font: 12.0px Helvetica"><b>Ptuple(list, repeats):</b> Collect the list items into an array as the return value.</li>
</ul>
<p class="p2"><br></p>
<p class="p2"><br></p>
<p class="p3"><b>Additional Random Number Generators</b></p>
<p class="p2"><br></p>
<ul>
<li style="margin: 0.0px 0.0px 0.0px 0.0px; font: 12.0px Helvetica"><b>Pgbrown(lo, hi, step, length):</b> Brownian motion, geometric scale (multiplication).</li>
</ul>
<p class="p2"><br></p>
<ul>
<li style="margin: 0.0px 0.0px 0.0px 0.0px; font: 12.0px Helvetica"><b>Pbeta(lo, hi, prob1, prob2, length):</b> Beta distribution, where prob1 = &#x03B1; (alpha) and prob2 = &#x03B2; (beta).</li>
<li style="margin: 0.0px 0.0px 0.0px 0.0px; font: 12.0px Helvetica"><b>Pcauchy(mean, spread, length):</b> Cauchy distribution.</li>
<li style="margin: 0.0px 0.0px 0.0px 0.0px; font: 12.0px Helvetica"><b>Pgauss(mean, dev, length):</b> Guassian (normal) distribution.</li>
<li style="margin: 0.0px 0.0px 0.0px 0.0px; font: 12.0px Helvetica"><b>Phprand(lo, hi, length):</b> Returns the greater of two equal-distribution random numbers.</li>
<li style="margin: 0.0px 0.0px 0.0px 0.0px; font: 12.0px Helvetica"><b>Plprand(lo, hi, length):</b> Returns the lesser of two equal-distribution random numbers.</li>
<li style="margin: 0.0px 0.0px 0.0px 0.0px; font: 12.0px Helvetica"><b>Pmeanrand(lo, hi, length):</b> Returns the average of two equal-distribution random numbers, i.e., (x +<span class="Apple-converted-space">Â  </span>y) / 2.</li>
<li style="margin: 0.0px 0.0px 0.0px 0.0px; font: 12.0px Helvetica"><b>Ppoisson(mean, length):</b> Poisson distribution.</li>
</ul>
<p class="p2"><br></p>
<ul>
<li style="margin: 0.0px 0.0px 0.0px 0.0px; font: 12.0px Helvetica"><b>Pprob(distribution, lo, hi, length, tableSize):</b> Arbitrary distribution, based on a probability table.</li>
</ul>
<p class="p2"><br></p>
<p class="p2"><br></p>
<p class="p4"><b>Functional descriptions of patterns</b></p>
<p class="p2"><br></p>
<p class="p5"><b>List Patterns</b></p>
<p class="p2"><br></p>
<p class="p3">The most obvious thing one would want to do with a pattern is to give it a list of values and have it read them out in order. You have a couple of choices, which differ in their handling of the 'repeats' parameter.</p>
<p class="p2"><br></p>
<p class="p3"><b>Pseq(list, repeats, offset):</b> Play through the entire list 'repeats' times.</p>
<p class="p3"><b>Pser(list, repeats, offset):</b> Play through the list as many times as needed, but output only 'repeats' items.</p>
<p class="p2"><br></p>
<p class="p6"><span class="s2">Pseq</span><span class="s3">(#[1, 2, 3], 4).asStream.all;<span class="Apple-tab-span">	</span></span>// 12 items = 4 repeats * 3 items</p>
<p class="p7"><span class="s2">Pser</span>(#[1, 2, 3], 4).asStream.all;<span class="Apple-tab-span">	</span><span class="s1">// 4 items only</span></p>
<p class="p2"><br></p>
<p class="p3"><span class="s4"><a href="../Patterns/Pseq.html">Pseq</a></span> is an obvious choice for streaming out known pitch and rhythm values.</p>
<p class="p2"><br></p>
<p class="p3">Before playing a Pbind pattern such as this, make sure the server is booted.</p>
<p class="p2"><br></p>
<p class="p8">s.boot;</p>
<p class="p9"><br></p>
<p class="p8">(</p>
<p class="p8">p = <span class="s5">Pbind</span>(</p>
<p class="p8"><span class="Apple-tab-span">	</span><span class="s6">\degree</span>, <span class="s5">Pseq</span>(#[0, 0, 4, 4, 5, 5, 4], 1),</p>
<p class="p8"><span class="Apple-tab-span">	</span><span class="s6">\dur</span>, <span class="s5">Pseq</span>(#[0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 1], 1)</p>
<p class="p8">).play;</p>
<p class="p7">)</p>
<p class="p2"><br></p>
<p class="p3">To stop the examples in this file, use the "stop" keyboard shortcut (cmd-. on Mac OSX, alt-. on Windows, check documentation for other editors). Or:</p>
<p class="p2"><br></p>
<p class="p8">p.stop;</p>
<p class="p2"><br></p>
<p class="p3">A variation, <a href="../Patterns/Pslide.html"><span class="s2">Pslide</span></a>, plays overlapping segments of the input list.</p>
<p class="p2"><br></p>
<p class="p3"><b>Pslide(list, repeats, len, step, start, wrapAtEnd)</b></p>
<p class="p3">repeats: <span class="Apple-tab-span">	</span>number of segments</p>
<p class="p3">len:<span class="Apple-tab-span">	</span> <span class="Apple-tab-span">	</span>length of each segment</p>
<p class="p3">step:<span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>is how far to step the start of each segment from previous.</p>
<p class="p3">start:<span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>what index to start at.</p>
<p class="p3">wrapAtEnd: if true (default), indexing wraps around if goes past beginning or end. If false, the pattern stops if it hits a nil element or goes outside the list bounds.</p>
<p class="p2"><br></p>
<p class="p3">If step == 1, then the first segment is at 'start', the second at 'start' + 1, and so on.</p>
<p class="p2"><br></p>
<p class="p7"><span class="s2">Pslide</span>(#[1, 2, 3, 4, 5, 6, 7, 8], 10, 3, 1, 0, <span class="s2">false</span>).asStream.all;</p>
<p class="p10"><br></p>
<p class="p6">// or, to show the segments as separate arrays</p>
<p class="p7"><span class="s2">Pslide</span>(#[1, 2, 3, 4, 5, 6, 7, 8], 10, 3, 1, 0, <span class="s2">false</span>).clump(3).asStream.all;</p>
<p class="p10"><br></p>
<p class="p6">// Flock of Seagulls!</p>
<p class="p7">(</p>
<p class="p8">p = <span class="s5">Pbind</span>(</p>
<p class="p8"><span class="Apple-tab-span">	</span><span class="s6">\degree</span>, <span class="s5">Pslide</span>((-6, -4 .. 12), 8, 3, 1, 0),</p>
<p class="p8"><span class="Apple-tab-span">	</span><span class="s6">\dur</span>, <span class="s5">Pseq</span>(#[0.1, 0.1, 0.2], <span class="s5">inf</span>),</p>
<p class="p11"><span class="s3"><span class="Apple-tab-span">	</span></span>\sustain<span class="s3">, 0.15</span></p>
<p class="p8">).play;</p>
<p class="p7">)</p>
<p class="p2"><br></p>
<p class="p3"><b>Random-order list patterns</b></p>
<p class="p2"><br></p>
<p class="p3"><b>Prand(list, repeats):</b> Choose items from the list randomly (same as list.choose).</p>
<p class="p2"><br></p>
<p class="p6">// Prand: given scale degrees (pentatonic) with equal probability of each</p>
<p class="p7">(</p>
<p class="p8">p = <span class="s5">Pbind</span>(</p>
<p class="p8"><span class="Apple-tab-span">	</span><span class="s6">\degree</span>, <span class="s5">Prand</span>([0, 1, 2, 4, 5], <span class="s5">inf</span>),</p>
<p class="p8"><span class="Apple-tab-span">	</span><span class="s6">\dur</span>, 0.25</p>
<p class="p8">).play;</p>
<p class="p7">)</p>
<p class="p2"><br></p>
<p class="p3"><b>Pxrand(list, repeats):</b> Choose randomly, but never repeat the same item twice in immediate succession.</p>
<p class="p2"><br></p>
<p class="p6">// Pxrand: same as above but never repeats a pitch twice in a row</p>
<p class="p7">(</p>
<p class="p8">p = <span class="s5">Pbind</span>(</p>
<p class="p8"><span class="Apple-tab-span">	</span><span class="s6">\degree</span>, <span class="s5">Pxrand</span>([0, 1, 2, 4, 5], <span class="s5">inf</span>),</p>
<p class="p8"><span class="Apple-tab-span">	</span><span class="s6">\dur</span>, 0.25</p>
<p class="p8">).play;</p>
<p class="p7">)</p>
<p class="p2"><br></p>
<p class="p3"><b>Pshuf(list, repeats):</b> Shuffle the list in random order, and use the same random order 'repeats' times. Like list.scramble.</p>
<p class="p2"><br></p>
<p class="p6">// Pshuf: randomly ordered once and repeated</p>
<p class="p7">(</p>
<p class="p8">p = <span class="s5">Pbind</span>(</p>
<p class="p8"><span class="Apple-tab-span">	</span><span class="s6">\degree</span>, <span class="s5">Pshuf</span>([0, 1, 2, 4, 5], <span class="s5">inf</span>),</p>
<p class="p8"><span class="Apple-tab-span">	</span><span class="s6">\dur</span>, 0.25</p>
<p class="p8">).play;</p>
<p class="p7">)</p>
<p class="p2"><br></p>
<p class="p3"><b>Pwrand(list, weights, repeats):</b> Choose randomly, according to weighted probabilities (same as list.wchoose(weights)).</p>
<p class="p2"><br></p>
<p class="p6">// Pwrand: these probabilities favor triadic notes from scale degrees</p>
<p class="p7">(</p>
<p class="p8">p = <span class="s5">Pbind</span>(</p>
<p class="p8"><span class="Apple-tab-span">	</span><span class="s6">\degree</span>, <span class="s5">Pwrand</span>((0..7), [4, 1, 3, 1, 3, 2, 1].normalizeSum, <span class="s5">inf</span>),</p>
<p class="p8"><span class="Apple-tab-span">	</span><span class="s6">\dur</span>, 0.25</p>
<p class="p8">).play;</p>
<p class="p7">)</p>
<p class="p2"><br></p>
<p class="p3"><b>Pwalk(list, stepPattern, directionPattern, startPos):</b> Random walk over the list. This pattern is a bit more complicated; see its help file for details.</p>
<p class="p2"><br></p>
<p class="p2"><br></p>
<p class="p5"><b>Interlacing values and making arrays</b></p>
<p class="p2"><br></p>
<p class="p3">These are opposing operations: interlacing means splitting arrays and merging them into a stream of single values, and arrays can be made out of single-value streams as well.</p>
<p class="p2"><br></p>
<p class="p3"><b>Place(list, repeats, offset):</b> Take one from each item in the main array item in succession. Hard to explain, easier to see:</p>
<p class="p2"><br></p>
<p class="p7">Place([0, [1, 2], [3, 4, 5]], 3).asStream.all;</p>
<p class="p7">--&gt; [ 0, 1, 3, 0, 2, 4, 0, 1, 5 ]</p>
<p class="p2"><br></p>
<p class="p3">If we turn this into a matrix and read vertically, the original arrays are clearly visible:</p>
<p class="p2"><br></p>
<p class="p7"><span class="s2">Place</span>([0, [1, 2], [3, 4, 5]], 3).clump(3).do(<span class="s2">_</span>.postln);</p>
<p class="p10"><br></p>
<p class="p6"><span class="s3">[ 0, 1, 3 ]<span class="Apple-tab-span">	</span></span>// leftmost column: 0 from first Place item</p>
<p class="p6"><span class="s3">[ 0, 2, 4 ]<span class="Apple-tab-span">	</span></span>// second column: alternates between 1 and 2, from second Place item</p>
<p class="p6"><span class="s3">[ 0, 1, 5 ]<span class="Apple-tab-span">	</span></span>// third column: 3, 4, 5 from third Place item</p>
<p class="p2"><br></p>
<p class="p3"><b>Ppatlace(list, repeats, offset):</b> Take one value from each sub-pattern in order.</p>
<p class="p2"><br></p>
<p class="p6">// Hanon exercise</p>
<p class="p7">(</p>
<p class="p8">p = <span class="s5">Pbind</span>(</p>
<p class="p12"><span class="s3"><span class="Apple-tab-span">	</span></span><span class="s6">\degree</span><span class="s3">, </span>Ppatlace<span class="s3">([</span></p>
<p class="p13"><span class="s3"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span></span><span class="s5">Pseries</span><span class="s3">(0, 1, 8),<span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span></span>// first, third etc. notes</p>
<p class="p13"><span class="s3"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span></span><span class="s5">Pseries</span><span class="s3">(2, 1, 7)<span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span></span>// second, fourth etc. notes</p>
<p class="p8"><span class="Apple-tab-span">	</span>], <span class="s5">inf</span>),</p>
<p class="p8"><span class="Apple-tab-span">	</span><span class="s6">\dur</span>, 0.25</p>
<p class="p8">).play;</p>
<p class="p7">)</p>
<p class="p2"><br></p>
<p class="p3">That's also a taste of things to come: Patterns can be nested.</p>
<p class="p2"><br></p>
<p class="p3"><b>Ptuple(list, repeats):</b> Get one value from each item in the array, and return all of them as an array of values.</p>
<p class="p2"><br></p>
<p class="p6">// Chords</p>
<p class="p6">// \degree receives [7, 9, 4], then [6, 7, 4] successively, expanded to chords on the server</p>
<p class="p7">(</p>
<p class="p8">p = <span class="s5">Pbind</span>(</p>
<p class="p11"><span class="s3"><span class="Apple-tab-span">	</span></span>\degree<span class="s3">, </span><span class="s5">Ptuple</span><span class="s3">([</span></p>
<p class="p8"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="s5">Pseries</span>(7, -1, 8),</p>
<p class="p8"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="s5">Pseq</span>([9, 7, 7, 7, 4, 4, 2, 2], 1),</p>
<p class="p8"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="s5">Pseq</span>([4, 4, 4, 2, 2, 0, 0, -3], 1)</p>
<p class="p8"><span class="Apple-tab-span">	</span>], 1),</p>
<p class="p8"><span class="Apple-tab-span">	</span><span class="s6">\dur</span>, 1</p>
<p class="p8">).play;</p>
<p class="p7">)</p>
<p class="p2"><br></p>
<p class="p5"><b>Generating values</b></p>
<p class="p2"><br></p>
<p class="p3"><b>Arithmetic and geometric series</b></p>
<p class="p2"><br></p>
<p class="p3">Now, let's move to patterns that produce values mathematically, without using a predefined list.</p>
<p class="p2"><br></p>
<p class="p3"><b>Pseries(start, step, length):</b> Arithmetic series, successively adding 'step' to the starting value, returning a total of 'length' items.</p>
<p class="p3"><b>Pgeom(start, grow, length):</b> Geometric series, successively multiplying the current value by 'grow'.</p>
<p class="p2"><br></p>
<p class="p6">// Use Pseries for a scale and Pgeom for an accelerando</p>
<p class="p7">(</p>
<p class="p8">p = <span class="s5">Pbind</span>(</p>
<p class="p8"><span class="Apple-tab-span">	</span><span class="s6">\degree</span>, <span class="s5">Pseries</span>(-7, 1, 15),</p>
<p class="p8"><span class="Apple-tab-span">	</span><span class="s6">\dur</span>, <span class="s5">Pgeom</span>(0.5, 0.89140193218427, 15)</p>
<p class="p8">).play;</p>
<p class="p7">)</p>
<p class="p2"><br></p>
<p class="p3"><b>Third-party extension alert:</b> If you want an arithmetic or geometric series to start at one number and end at another specific number, the step size/multiplier must be calculated from the endpoints and the number of items desired. The ddwPatterns quark includes a convenience method, <b>fromEndpoints</b>, for both Pseries and Pgeom that performs this calculation. It's necessary to give an exact number of repeats, at least two and less than infinity.</p>
<p class="p2"><br></p>
<p class="p6"><span class="s3">p = </span><span class="s2">Pgeom</span><span class="s3">.fromEndpoints(0.5, 0.1, 15);<span class="Apple-tab-span">	</span></span>// error if ddwPatterns not installed</p>
<p class="p7">p.postcs;</p>
<p class="p2"><br></p>
<p class="p3">Prints:</p>
<p class="p7">Pgeom(0.5, 0.89140193218427, 15)</p>
<p class="p2"><br></p>
<p class="p2"><br></p>
<p class="p3"><b>Random numbers and probability distributions</b></p>
<p class="p2"><br></p>
<ul>
<li style="margin: 0.0px 0.0px 0.0px 0.0px; font: 12.0px Helvetica"><b>Pwhite(lo, hi, length):</b> Produces 'length' random numbers with equal distribution ('white' refers to white noise).</li>
<li style="margin: 0.0px 0.0px 0.0px 0.0px; font: 12.0px Helvetica"><b>Pexprand(lo, hi, length):</b> Same, but the random numbers have an exponential distribution, favoring lower numbers. This is good for frequencies, and also durations (because you need more notes with a shorter duration to balance the weight of longer notes).</li>
<li style="margin: 0.0px 0.0px 0.0px 0.0px; font: 12.0px Helvetica"><b>Pbrown(lo, hi, step, length):</b> Brownian motion. Each value adds a random step to the previous value, where the step has an equal distribution between -step and +step.</li>
<li style="margin: 0.0px 0.0px 0.0px 0.0px; font: 12.0px Helvetica"><b>Pgbrown(lo, hi, step, length):</b> Brownian motion on a geometric scale. Each value multiplies a random step factor to the previous value.</li>
</ul>
<p class="p2"><br></p>
<ul>
<li style="margin: 0.0px 0.0px 0.0px 0.0px; font: 12.0px Helvetica"><b>Pbeta(lo, hi, prob1, prob2, length):</b> Beta distribution, where prob1 = &#x03B1; (alpha) and prob2 = &#x03B2; (beta).</li>
<li style="margin: 0.0px 0.0px 0.0px 0.0px; font: 12.0px Helvetica"><b>Pcauchy(mean, spread, length):</b> Cauchy distribution.</li>
<li style="margin: 0.0px 0.0px 0.0px 0.0px; font: 12.0px Helvetica"><b>Pgauss(mean, dev, length):</b> Guassian (normal) distribution.</li>
<li style="margin: 0.0px 0.0px 0.0px 0.0px; font: 12.0px Helvetica"><b>Phprand(lo, hi, length):</b> Returns the greater of two equal-distribution random numbers.</li>
<li style="margin: 0.0px 0.0px 0.0px 0.0px; font: 12.0px Helvetica"><b>Plprand(lo, hi, length):</b> Returns the lesser of two equal-distribution random numbers.</li>
<li style="margin: 0.0px 0.0px 0.0px 0.0px; font: 12.0px Helvetica"><b>Pmeanrand(lo, hi, length):</b> Returns the average of two equal-distribution random numbers, i.e., (x + y) / 2.</li>
<li style="margin: 0.0px 0.0px 0.0px 0.0px; font: 12.0px Helvetica"><b>Ppoisson(mean, length):</b> Poisson distribution.</li>
</ul>
<p class="p2"><br></p>
<ul>
<li style="margin: 0.0px 0.0px 0.0px 0.0px; font: 12.0px Helvetica"><b>Pprob(distribution, lo, hi, length, tableSize):</b> Given an array of relative probabilities across the desired range (a histogram) representing an arbitrary distribution, generates random numbers corresponding to that distribution.</li>
</ul>
<p class="p2"><br></p>
<p class="p3">To see a distribution, make a histogram out of it.</p>
<p class="p2"><br></p>
<p class="p7"><span class="s2">Pmeanrand</span>(0.0, 1.0, <span class="s2">inf</span>).asStream.nextN(10000).histo(200, 0.0, 1.0).plot;</p>
<p class="p2"><br></p>
<p class="p2"><br></p>
<p class="p5"><b>Catchall Patterns</b></p>
<p class="p2"><br></p>
<p class="p3">Not everything is pre-written as a pattern class. These patterns let you embed custom logic.</p>
<p class="p2"><br></p>
<p class="p3"><b>Pfunc(nextFunc, resetFunc):</b> The next value is the return value from evaluating nextFunc. If .reset is called on a stream made from this pattern, resetFunc is evaluated. The stream will run indefinitely until nextFunc returns nil.</p>
<p class="p2"><br></p>
<p class="p3"><b>Pfuncn(func, repeats):</b> Like Pfunc, output values come from evaluating the function. Pfuncn, however, returns exactly 'repeats' values and then stops. The default number of repeats is 1.</p>
<p class="p2"><br></p>
<p class="p3"><b>Proutine(routineFunc):</b> Use the routineFunc in a routine. The stream's output values are whatever this function .yields. Proutine ends when it yields nil.</p>
<p class="p2"><br></p>
<p class="p2"><br></p>
<p class="p3">Next, we'll look at the central pattern for audio sequencing: <b>Pbind</b>.</p>
<p class="p2"><br></p>
<p class="p14"><span class="s3">Previous:<span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><a href="PG_01_Introduction.html"><span class="s7">PG_01_Introduction</span></a></span></p>
<p class="p14"><span class="s3">Next:<span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><a href="PG_03_What_Is_Pbind.html"><span class="s7">PG_03_What_Is_Pbind</span></a></span></p>
</body>
</html>
