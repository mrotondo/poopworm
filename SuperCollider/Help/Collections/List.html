<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta http-equiv="Content-Style-Type" content="text/css">
<title></title>
<meta name="Generator" content="Cocoa HTML Writer">
<meta name="CocoaVersion" content="949.43">
<style type="text/css">
p.p1 {margin: 0.0px 0.0px 0.0px 0.0px; font: 12.0px Helvetica}
p.p2 {margin: 0.0px 0.0px 0.0px 0.0px; font: 12.0px Helvetica; min-height: 14.0px}
p.p3 {margin: 0.0px 0.0px 0.0px 0.0px; font: 12.0px Helvetica; color: #0021e7}
p.p4 {margin: 0.0px 0.0px 0.0px 0.0px; font: 9.0px Monaco}
p.p5 {margin: 0.0px 0.0px 0.0px 0.0px; font: 14.0px Helvetica}
p.p6 {margin: 0.0px 0.0px 0.0px 42.0px; font: 12.0px Helvetica}
p.p7 {margin: 0.0px 0.0px 0.0px 42.0px; font: 12.0px Helvetica; min-height: 14.0px}
p.p8 {margin: 0.0px 0.0px 0.0px 42.0px; font: 9.0px Monaco}
p.p9 {margin: 0.0px 0.0px 0.0px 42.0px; font: 9.0px Monaco; color: #ad140d}
p.p10 {margin: 0.0px 0.0px 0.0px 42.0px; font: 12.0px Monaco; min-height: 16.0px}
p.p11 {margin: 0.0px 0.0px 0.0px 42.0px; font: 10.0px Monaco; min-height: 14.0px}
p.p12 {margin: 0.0px 0.0px 0.0px 42.0px; font: 9.0px Monaco; min-height: 12.0px}
p.p13 {margin: 0.0px 0.0px 0.0px 42.0px; font: 12.0px Helvetica; color: #001bb9; min-height: 14.0px}
span.s1 {font: 18.0px Helvetica}
span.s2 {color: #000000}
span.s3 {color: #001bb9}
span.s4 {color: #606060}
span.s5 {color: #2c7014}
span.Apple-tab-span {white-space:pre}
</style>
</head>
<body>
<p class="p1"><span class="s1"><b>List<span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span></b></span><b>list of items of variable size</b></p>
<p class="p2"><br></p>
<p class="p3"><span class="s2"><b>Inherits from: </b><a href="../Core/Object.html"><b>Object</b></a><b> : </b><a href="Collection.html"><b>Collection</b></a></span><span class="s3"><b> :</b></span><span class="s2"><b> </b><a href="SequenceableCollection.html"><b>SequenceableCollection</b></a></span></p>
<p class="p2"><br></p>
<p class="p1">List is a subclass of SequenceableCollection with unlimited growth in size. Although not a subclass of <a href="Array.html"><span class="s3">Array</span></a> or its superclass <a href="ArrayedCollection.html"><span class="s3">ArrayedCollection</span></a> it uses an Array in its implementation and is in many cases interchangeable with one. (List implements many of the same methods as Array.)</p>
<p class="p2"><br></p>
<p class="p1">Arrays have a fixed maximum size. If you add beyond that size a new Array is created and returned, but you must use an assignment statement or the new array will be lost. (See the <b>Array </b>helpfile.) List has no size limitation and is thus more flexible, but has slightly more overhead.</p>
<p class="p2"><br></p>
<p class="p4">(</p>
<p class="p4">x = <span class="s3">Array</span>.new(3);<span class="Apple-converted-space"> </span></p>
<p class="p4">y = <span class="s3">List</span>.new(3);<span class="Apple-converted-space"> </span></p>
<p class="p4">5.do({ <span class="s3">arg</span> i; z = x.add(i); y.add(i); });<span class="Apple-converted-space"> </span></p>
<p class="p4">x.postln; z.postln; y.postln;</p>
<p class="p4">)</p>
<p class="p2"><br></p>
<p class="p1">Many of List's methods are inherited from <a href="SequenceableCollection.html"><span class="s3"><b>SequenceableCollection</b></span></a><b> </b>or <a href="Collection.html"><span class="s3"><b>Collection</b></span></a><b> </b>and are documented in those helpfiles.</p>
<p class="p2"><br></p>
<p class="p2"><br></p>
<p class="p5"><b>Class Methods</b></p>
<p class="p2"><br></p>
<p class="p1"><b>*new(size)</b></p>
<p class="p6">Creates a List with the initial capacity given by <b>size</b>.</p>
<p class="p7"><br></p>
<p class="p1"><b>*newClear(size)</b></p>
<p class="p6">Creates a List with the initial capacity given by <b>size</b> and slots filled with nil.</p>
<p class="p7"><br></p>
<p class="p1"><b>*copyInstance(aList)</b></p>
<p class="p6">Creates a List by copying <b>aList's</b> array variable.</p>
<p class="p7"><br></p>
<p class="p1"><b>*newUsing(anArray)</b></p>
<p class="p6">Creates a List using <b>anArray</b>.</p>
<p class="p7"><br></p>
<p class="p7"><br></p>
<p class="p7"><br></p>
<p class="p5"><b>Instance Methods</b></p>
<p class="p2"><br></p>
<p class="p1"><b>asArray</b></p>
<p class="p6">Returns a new <b>Array</b> based upon this List.</p>
<p class="p7"><br></p>
<p class="p1"><b>array</b></p>
<p class="p6">Returns the List's Array, allowing it to be manipulated directly. This should only be necessary for exotic manipulations not implemented in List or its superclasses.</p>
<p class="p7"><br></p>
<p class="p8">(</p>
<p class="p8">x = <span class="s3">List</span>[1, 2, 3];</p>
<p class="p8">x.array.add(<span class="s4">"foo"</span>);</p>
<p class="p8">x.postln;</p>
<p class="p8">)</p>
<p class="p7"><br></p>
<p class="p1"><b>array_(anArray)</b></p>
<p class="p6">Sets the List's Array.</p>
<p class="p7"><br></p>
<p class="p1"><b>at(index)</b></p>
<p class="p6">Return the <b>item</b> at <b>index</b>.</p>
<p class="p7"><br></p>
<p class="p8"><span class="s3">List</span>[ 1, 2, 3 ].at(0).postln;</p>
<p class="p7"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span></p>
<p class="p1"><b>clipAt(index)</b></p>
<p class="p6">Same as <b>at</b>, but values for <b>index</b> greater than the size of the List will be clipped to the last index.</p>
<p class="p7"><br></p>
<p class="p8">y = <span class="s3">List</span>[ 1, 2, 3 ];</p>
<p class="p8">y.clipAt(13).postln;</p>
<p class="p7"><span class="Apple-converted-space"> </span></p>
<p class="p1"><b>wrapAt(index)</b></p>
<p class="p6">Same as <b>at</b>, but values for <b>index</b> greater than the size of the List will be wrapped around to 0.</p>
<p class="p7"><br></p>
<p class="p8">y = <span class="s3">List</span>[ 1, 2, 3 ];</p>
<p class="p9"><span class="s2">y.wrapAt(3).postln; </span>// this returns the value at index 0</p>
<p class="p9"><span class="s2">y.wrapAt(4).postln; </span>// this returns the value at index 1</p>
<p class="p7"><br></p>
<p class="p1"><b>foldAt(index)</b></p>
<p class="p6">Same as <b>at</b>, but values for <b>index</b> greater than the size of the List will be folded back.</p>
<p class="p7"><br></p>
<p class="p8">y = <span class="s3">List</span>[ 1, 2, 3 ];</p>
<p class="p9"><span class="s2">y.foldAt(3).postln; </span>// this returns the value at index 1</p>
<p class="p9"><span class="s2">y.foldAt(4).postln; </span>// this returns the value at index 0</p>
<p class="p9"><span class="s2">y.foldAt(5).postln; </span>// this returns the value at index 1</p>
<p class="p7"><br></p>
<p class="p1"><b>put(index, item)</b></p>
<p class="p6">Put <b>item</b> at <b>index</b>, replacing what is there.</p>
<p class="p7"><br></p>
<p class="p1"><b>clipPut(index, item)</b></p>
<p class="p6">Same as <b>put</b>, but values for <b>index</b> greater than the size of the List will be clipped to the last index.</p>
<p class="p7"><span class="Apple-converted-space"> </span></p>
<p class="p1"><b>wrapPut(index, item)</b></p>
<p class="p6">Same as <b>put</b>, but values for <b>index</b> greater than the size of the List will be wrapped around to 0.</p>
<p class="p7"><br></p>
<p class="p1"><b>foldPut(index)</b></p>
<p class="p6">Same as <b>put</b>, but values for <b>index</b> greater than the size of the List will be folded back.</p>
<p class="p7"><br></p>
<p class="p1"><b>add(item)</b></p>
<p class="p6">Adds an <b>item</b> to the end of the List.</p>
<p class="p7"><br></p>
<p class="p1"><b>addFirst(item)</b></p>
<p class="p6">Inserts the <b>item</b> at the beginning of the List.</p>
<p class="p10"><br></p>
<p class="p1"><b>insert(index, item)</b></p>
<p class="p6">Inserts the <b>item</b> into the contents of the List at the indicated <b>index</b>.</p>
<p class="p10"><br></p>
<p class="p1"><b>pop</b></p>
<p class="p6">Remove and return the last element of the List.</p>
<p class="p7"><br></p>
<p class="p1"><b>grow(sizeIncrease)</b></p>
<p class="p6">Increase the size of the List by <b>sizeIncrease </b>number of slots.</p>
<p class="p7"><br></p>
<p class="p1"><b>removeAt(index)</b></p>
<p class="p6">Remove and return the element at <b>index</b>, shrinking the size of the List.</p>
<p class="p7"><br></p>
<p class="p8">y = <span class="s3">List</span>[ 1, 2, 3 ];<span class="Apple-converted-space"> </span></p>
<p class="p8">y.removeAt(1);<span class="Apple-converted-space"> </span></p>
<p class="p8">y.postln;</p>
<p class="p7"><br></p>
<p class="p1"><b>fill(value)</b></p>
<p class="p6">Inserts the item into the contents of the receiver, possibly returning a new collection. Note the difference between this and Collection's *fill.</p>
<p class="p7"><br></p>
<p class="p8">(</p>
<p class="p8"><span class="s3">var</span> z;</p>
<p class="p8">z = <span class="s3">List</span>[1, 2, 3, 4];</p>
<p class="p8">z.fill(4).postln;</p>
<p class="p8">z.fill([1,2,3,4]).postln;</p>
<p class="p8">)</p>
<p class="p11"><br></p>
<p class="p1"><b>do(function)</b></p>
<p class="p6">Iterate over the elements in order, calling the function for each element. The function is passed two arguments, the element and an index.</p>
<p class="p7"><br></p>
<p class="p8"><span class="s3">List</span>[<span class="s5">'a'</span>, <span class="s5">'b'</span>, <span class="s5">'c'</span>].do({ <span class="s3">arg</span> item, i; [i, item].postln; });</p>
<p class="p12"><br></p>
<p class="p1"><b>reverseDo(function)</b></p>
<p class="p6">Iterate over the elements in reverse order, calling the function for each element. The function is passed two arguments, the element and an index.</p>
<p class="p7"><br></p>
<p class="p8"><span class="s3">List</span>[<span class="s5">'a'</span>, <span class="s5">'b'</span>, <span class="s5">'c'</span>].reverseDo({ <span class="s3">arg</span> item, i; [i, item].postln; });</p>
<p class="p12"><br></p>
<p class="p1"><b>pairsDo(function)</b></p>
<p class="p6">Calls function for each subsequent pair of elements in the SequentialCollection.</p>
<p class="p6">The function is passed the two elements and an index.</p>
<p class="p7"><br></p>
<p class="p8"><span class="s3">List</span>[1, 2, 3, 4, 5, 6].pairsDo({ <span class="s3">arg</span> a, b; [a, b].postln; });</p>
<p class="p7"><br></p>
<p class="p1"><b>copyRange(start, end)</b></p>
<p class="p6">Return a new List which is a copy of the indexed slots of the receiver from start to end.</p>
<p class="p10"><br></p>
<p class="p8">(</p>
<p class="p8"><span class="s3">var</span> y, z;</p>
<p class="p8">z = <span class="s3">List</span>[1, 2, 3, 4, 5];</p>
<p class="p8">y = z.copyRange(1,3);</p>
<p class="p8">z.postln;</p>
<p class="p8">y.postln;</p>
<p class="p8">)</p>
<p class="p12"><br></p>
<p class="p1"><b>copySeries(first, second, last)</b></p>
<p class="p6">Return a new List consisting of the values starting at <b>first</b>, then every step of the distance between <b>first</b> and <b>second</b>, up until <b>last</b>.</p>
<p class="p10"><br></p>
<p class="p8">(</p>
<p class="p8"><span class="s3">var</span> y, z;</p>
<p class="p8">z = <span class="s3">List</span>[1, 2, 3, 4, 5, 6];</p>
<p class="p8">y = z.copySeries(0, 2, 5);</p>
<p class="p8">y.postln;</p>
<p class="p8">)</p>
<p class="p12"><br></p>
<p class="p1"><b>putSeries(first, second, last, value)</b></p>
<p class="p6">Put <b>value</b> at every index starting at <b>first</b>, then every step of the distance between <b>first</b> and <b>second</b>, up until <b>last</b>.</p>
<p class="p10"><br></p>
<p class="p8">(</p>
<p class="p8"><span class="s3">var</span> y, z;</p>
<p class="p8">z = <span class="s3">List</span>[1, 2, 3, 4, 5, 6];</p>
<p class="p8">y = z.putSeries(0, 2, 5, <span class="s4">"foo"</span>);</p>
<p class="p8">y.postln;</p>
<p class="p8">)</p>
<p class="p12"><br></p>
<p class="p1"><b>reverse</b></p>
<p class="p6">Return a new List whose elements are reversed.</p>
<p class="p7"><br></p>
<p class="p8">(</p>
<p class="p8"><span class="s3">var</span> y, z;</p>
<p class="p8">z = <span class="s3">List</span>[1, 2, 3, 4];</p>
<p class="p8">y = z.reverse;</p>
<p class="p8">z.postln;</p>
<p class="p8">y.postln;</p>
<p class="p8">)</p>
<p class="p12"><br></p>
<p class="p1"><b>scramble</b></p>
<p class="p6">Returns a new List whose elements have been scrambled. The receiver is unchanged.</p>
<p class="p13"><br></p>
<p class="p8"><span class="s3">List</span>[1, 2, 3, 4, 5, 6].scramble.postln;</p>
<p class="p10"><br></p>
<p class="p1"><b>mirror</b></p>
<p class="p6">Return a new List which is the receiver made into a palindrome.<span class="Apple-converted-space"> </span></p>
<p class="p6">The receiver is unchanged.</p>
<p class="p7"><br></p>
<p class="p8"><span class="s3">List</span>[1, 2, 3, 4].mirror.postln;</p>
<p class="p7"><br></p>
<p class="p1"><b>mirror1</b></p>
<p class="p6">Return a new List which is the receiver made into a palindrome with the last element removed.<span class="Apple-converted-space"> </span></p>
<p class="p6">This is useful if the list will be repeated cyclically, the first element will not get played twice.</p>
<p class="p6">The receiver is unchanged.</p>
<p class="p7"><br></p>
<p class="p8"><span class="s3">Lis</span>t[1, 2, 3, 4].mirror1.postln;</p>
<p class="p7"><br></p>
<p class="p1"><b>mirror2</b></p>
<p class="p6">Return a new List which is the receiver concatenated with a reversal of itself. The center element is duplicated. The receiver is unchanged.</p>
<p class="p7"><br></p>
<p class="p8"><span class="s3">Lis</span>t[1, 2, 3, 4].mirror2.postln;</p>
<p class="p7"><br></p>
<p class="p1"><b>stutter(n)</b></p>
<p class="p6">Return a new List whose elements are repeated n times. The receiver is unchanged.</p>
<p class="p7"><br></p>
<p class="p8"><span class="s3">Lis</span>t[1, 2, 3].stutter(2).postln;</p>
<p class="p7"><br></p>
<p class="p1"><b>rotate(n)</b></p>
<p class="p6">Return a new List whose elements are in rotated order. Negative n values rotate left, postive n values rotate right. The receiver is unchanged.</p>
<p class="p7"><br></p>
<p class="p8"><span class="s3">Lis</span>t[1, 2, 3, 4, 5].rotate(1).postln;</p>
<p class="p12"><br></p>
<p class="p8"><span class="s3">Lis</span>t[1, 2, 3, 4, 5].rotate(-1).postln;</p>
<p class="p12"><br></p>
<p class="p8"><span class="s3">Lis</span>t[1, 2, 3, 4, 5].rotate(3).postln;</p>
<p class="p7"><br></p>
<p class="p1"><b>pyramid</b></p>
<p class="p6">Return a new List whose elements have been reordered via one of 10 "counting" algorithms.</p>
<p class="p6">The algorithms are numbered 1 through 10. Run the examples to see the algorithms.</p>
<p class="p7"><br></p>
<p class="p8"><span class="s3">Lis</span>t[1, 2, 3, 4].pyramid(1).postln;</p>
<p class="p10"><br></p>
<p class="p8">(</p>
<p class="p8">10.do({ <span class="s3">arg</span> i;</p>
<p class="p8"><span class="Apple-tab-span">	</span><span class="s3">Lis</span>t[1, 2, 3, 4].pyramid(i + 1).postcs;</p>
<p class="p8">});</p>
<p class="p8">)</p>
<p class="p2"><br></p>
<p class="p1"><b>lace(length)</b></p>
<p class="p6">Returns a new List whose elements are interlaced sequences of the elements of the receiver's subcollections, up to size <b>length</b>. The receiver is unchanged.</p>
<p class="p7"><br></p>
<p class="p8">(</p>
<p class="p8">x = <span class="s3">List</span>[ [1, 2, 3], 6, <span class="s3">List</span>[<span class="s4">"foo"</span>, <span class="s5">'bar'</span>]];</p>
<p class="p8">y = x.lace(12);</p>
<p class="p8">x.postln;</p>
<p class="p8">y.postln;</p>
<p class="p8">)</p>
<p class="p7"><br></p>
<p class="p1"><b>permute(nthPermutation)</b></p>
<p class="p6">Returns a new List whose elements are the <b>nthPermutation</b> of the elements of the receiver. The receiver is unchanged.</p>
<p class="p7"><br></p>
<p class="p8">(</p>
<p class="p8">x = <span class="s3">List</span>[ 1, 2, 3];</p>
<p class="p8">6.do({|i| x.permute(i).postln;});</p>
<p class="p8">)</p>
<p class="p7"><br></p>
<p class="p1"><b>wrapExtend(length)</b></p>
<p class="p6">Returns a new List whose elements are repeated sequences of the receiver, up to size <b>length</b>. The receiver is unchanged.</p>
<p class="p7"><br></p>
<p class="p8">(</p>
<p class="p8">x = <span class="s3">List</span>[ 1, 2, 3, <span class="s4">"foo"</span>, <span class="s5">'bar'</span> ];</p>
<p class="p8">y = x.wrapExtend(9);</p>
<p class="p8">x.postln;</p>
<p class="p8">y.postln;</p>
<p class="p8">)</p>
<p class="p7"><br></p>
<p class="p1"><b>foldExtend(length)</b></p>
<p class="p6">Same as <b>lace</b> but the sequences fold back on the list elements.</p>
<p class="p12"><br></p>
<p class="p8">(</p>
<p class="p8">x = <span class="s3">List</span>[ 1, 2, <span class="s4">"foo"</span>];</p>
<p class="p8">y = x.foldExtend(9);</p>
<p class="p8">x.postln;</p>
<p class="p8">y.postln;</p>
<p class="p8">)</p>
<p class="p7"><br></p>
<p class="p1"><b>slide(windowLength, stepSize)</b></p>
<p class="p6">Return a new List whose elements are repeated subsequences from the receiver.<span class="Apple-converted-space"> </span></p>
<p class="p6">Easier to demonstrate than explain.</p>
<p class="p7"><br></p>
<p class="p8"><span class="s3">Lis</span>t[1, 2, 3, 4, 5, 6].slide(3, 1).postcs;</p>
<p class="p12"><br></p>
<p class="p8"><span class="s3">Lis</span>t[1, 2, 3, 4, 5, 6].slide(3, 2).postcs;</p>
<p class="p12"><br></p>
<p class="p8"><span class="s3">Lis</span>t[1, 2, 3, 4, 5, 6].slide(4, 1).postcs;</p>
<p class="p12"><br></p>
<p class="p1"><b>dump</b></p>
<p class="p6">Dump the List's Array.</p>
<p class="p7"><br></p>
<p class="p1"><b>clear</b></p>
<p class="p6">Replace the List's Array with a new empty one.</p>
</body>
</html>
