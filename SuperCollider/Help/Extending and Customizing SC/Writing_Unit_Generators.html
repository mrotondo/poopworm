<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta http-equiv="Content-Style-Type" content="text/css">
<title></title>
<meta name="Generator" content="Cocoa HTML Writer">
<meta name="CocoaVersion" content="949.35">
<style type="text/css">
p.p1 {margin: 0.0px 0.0px 0.0px 0.0px; font: 21.0px Helvetica}
p.p2 {margin: 0.0px 0.0px 0.0px 0.0px; font: 15.0px Helvetica; min-height: 18.0px}
p.p3 {margin: 0.0px 0.0px 0.0px 0.0px; font: 15.0px Helvetica}
p.p4 {margin: 0.0px 0.0px 0.0px 0.0px; font: 12.0px Monaco; color: #9b1e10}
p.p5 {margin: 0.0px 0.0px 0.0px 0.0px; font: 12.0px Monaco; color: #0025b4}
p.p6 {margin: 0.0px 0.0px 0.0px 0.0px; font: 12.0px Monaco; color: #9b1e10; min-height: 16.0px}
p.p7 {margin: 0.0px 0.0px 0.0px 0.0px; font: 12.0px Monaco}
p.p8 {margin: 0.0px 0.0px 0.0px 0.0px; font: 12.0px Monaco; min-height: 16.0px}
p.p9 {margin: 0.0px 0.0px 0.0px 0.0px; font: 14.0px Monaco}
p.p10 {margin: 0.0px 0.0px 0.0px 0.0px; font: 14.0px Monaco; min-height: 19.0px}
p.p11 {margin: 0.0px 0.0px 0.0px 0.0px; font: 19.0px Monaco; min-height: 26.0px}
p.p12 {margin: 0.0px 0.0px 0.0px 0.0px; font: 13.0px Helvetica; min-height: 16.0px}
p.p13 {margin: 0.0px 0.0px 0.0px 0.0px}
p.p14 {margin: 0.0px 0.0px 0.0px 0.0px; font: 12.0px Times; min-height: 14.0px}
p.p15 {margin: 0.0px 0.0px 0.0px 0.0px; font: 12.0px Monaco; color: #606060}
p.p16 {margin: 0.0px 0.0px 0.0px 0.0px; font: 12.0px Monaco; color: #000000}
p.p17 {margin: 0.0px 0.0px 0.0px 0.0px; font: 21.0px Helvetica; min-height: 25.0px}
span.s1 {color: #000000}
span.s2 {color: #0025b4}
span.s3 {font: 12.0px Monaco; color: #0025b4}
span.s4 {font: 14.0px Monaco}
span.s5 {font: 14.0px Courier}
span.s6 {font: 12.0px Helvetica}
span.s7 {color: #606060}
span.s8 {color: #416c1c}
span.s9 {font: 12.0px Monaco}
span.s10 {color: #9b1e10}
span.Apple-tab-span {white-space:pre}
</style>
</head>
<body>
<p class="p1">How Unit Generator plug-ins work.</p>
<p class="p2"><br></p>
<p class="p3">The server loads unit generator plug-ins when it starts up.</p>
<p class="p3">Unit Generator plug-ins are dynamically loaded libraries (DLLs) written in C++.</p>
<p class="p3">Each library may contain one or multiple unit generator definitions.</p>
<p class="p3">The server looks in the "plugins" directory for all files ending in .scx and calls the load() function in each one.</p>
<p class="p2"><br></p>
<p class="p3"><b>The load() function</b></p>
<p class="p2"><br></p>
<p class="p3">When the library is loaded the server calls the load() function in the library.</p>
<p class="p2"><br></p>
<p class="p3">The load function has two responsibilities:</p>
<p class="p3"><span class="Apple-tab-span">	</span>• It needs to store the passed in pointer to the InterfaceTable in a global variable.</p>
<p class="p3"><span class="Apple-tab-span">	</span>• It defines the unit generators.</p>
<p class="p2"><span class="Apple-tab-span">	</span></p>
<p class="p4">// InterfaceTable contains pointers to functions in the host (server).</p>
<p class="p5"><span class="s1">static </span>InterfaceTable<span class="s1"> *ft;</span></p>
<p class="p4">...</p>
<p class="p6"><br></p>
<p class="p4">// the load function is called by the host when the plug-in is loaded</p>
<p class="p7">void load(<span class="s2">InterfaceTable</span> *inTable)</p>
<p class="p7">{</p>
<p class="p4"><span class="s1"><span class="Apple-tab-span">	</span>ft = inTable; </span>// store pointer to InterfaceTable</p>
<p class="p8"><br></p>
<p class="p5"><span class="s1"><span class="Apple-tab-span">	</span></span>DefineSimpleUnit<span class="s1">(</span>MySaw<span class="s1">);</span></p>
<p class="p7">}</p>
<p class="p2"><br></p>
<p class="p3">Unit Generators are defined by calling a function in the InterfaceTable and passing it the name of the unit generator, the size of its C data struct, and pointers to functions for constructing and destructing it. The macro <span class="s3">DefineSimpleUnit</span> makes this more brief.</p>
<p class="p2"><br></p>
<p class="p9">#define DefineSimpleUnit(name) \</p>
<p class="p9"><span class="Apple-converted-space">       </span>(*ft-&gt;fDefineUnit)(#name, sizeof(name), (UnitCtorFunc)&amp;name##_Ctor, 0);</p>
<p class="p2"><br></p>
<p class="p3"><span class="s4">ft-&gt;fDefineUnit </span>is a function pointer in the InterfaceTable to the server function that defines a new unit generator.</p>
<p class="p2"><br></p>
<p class="p3"><span class="s4">#name </span>creates a string C from the name. In this case, "MySaw".</p>
<p class="p2"><br></p>
<p class="p3"><span class="s4">sizeof(name) </span>will be the size of the struct MySaw.</p>
<p class="p2"><br></p>
<p class="p3"><span class="s4">name##_Ctor </span>will macro-expand to <span class="s4">MySaw_Ctor</span>. There will need to be a function defined with this name.</p>
<p class="p2"><br></p>
<p class="p3"><span class="s4">0</span> is the argument for the Dtor, or destructor function, which is not needed for this unit generator.</p>
<p class="p10"><br></p>
<p class="p10"><br></p>
<p class="p3">So the macro:<span class="Apple-converted-space"> </span></p>
<p class="p2"><br></p>
<p class="p9">DefineSimpleUnit(MySaw);<span class="Apple-converted-space"> </span></p>
<p class="p8"><br></p>
<p class="p3">expands to this:</p>
<p class="p2"><br></p>
<p class="p9">(*ft-&gt;fDefineUnit)("MySaw", sizeof(MySaw), (UnitCtorFunc)&amp;MySaw_Ctor, 0);</p>
<p class="p10"><br></p>
<p class="p2"><br></p>
<p class="p3">A plug-in can also define things other than unit generators such as buffer fill (<span class="s5">"/b_gen")</span> commands.</p>
<p class="p11"><span class="Apple-tab-span">	</span></p>
<p class="p11"><br></p>
<p class="p1">Adding a Target to Xcode</p>
<p class="p12"><br></p>
<p class="p3">You will need to have the Developer Tools installed to do this.</p>
<p class="p3">Each group of plugins shares a target in Xcode, which outputs a single plugin, e.g MyUGens.scx.</p>
<p class="p2"><br></p>
<p class="p3">We will use an existing target as a template for our target. In this tutorial we will use ChaosUGens as a template, although you could use any target.<span class="Apple-converted-space"> </span></p>
<p class="p3">The frist step is to make a duplicate of ChaosUGens. To do this control-click on the ChaosUGens target and select "Duplicate".</p>
<p class="p2"><br></p>
<p class="p2"><br></p>
<p class="p13"><span class="s6"><img src="attachments/Writing_Unit_Generators/Pasted Graphic 1.png" alt="attachments/Writing_Unit_Generators/Pasted Graphic 1.png"></span></p>
<p class="p2"><br></p>
<p class="p3">Now we need to change the name of the target and it's output file. Double click on the "ChaosUGens copy" to open it's inspector.</p>
<p class="p2"><br></p>
<p class="p13"><span class="s6"><img src="attachments/Writing_Unit_Generators/Pasted Graphic 2.png" alt="attachments/Writing_Unit_Generators/Pasted Graphic 2.png"></span></p>
<p class="p2"><br></p>
<p class="p3">In the "Build" tab , search for the "Product Name" setting and change the value to "MyUGens".</p>
<p class="p2"><br></p>
<p class="p13"><span class="s6"><img src="attachments/Writing_Unit_Generators/Pasted Graphic 5.png" alt="attachments/Writing_Unit_Generators/Pasted Graphic 5.png"></span></p>
<p class="p14"><br></p>
<p class="p3">Now switch to the "General" tab and change the target name to "MyUGens".</p>
<p class="p2"><br></p>
<p class="p13"><span class="s6"><img src="attachments/Writing_Unit_Generators/Pasted Graphic.png" alt="attachments/Writing_Unit_Generators/Pasted Graphic.png"></span></p>
<p class="p14"><br></p>
<p class="p14"><br></p>
<p class="p3">Close the ChaosUGens inspector, expand the target's disclosure triangle, and then expand the "Compile Sources" disclosure triangle.</p>
<p class="p2"><br></p>
<p class="p2"><br></p>
<p class="p13"><span class="s6"><img src="attachments/Writing_Unit_Generators/Pasted Graphic 10.png" alt="attachments/Writing_Unit_Generators/Pasted Graphic 10.png"></span></p>
<p class="p14"><br></p>
<p class="p14"><br></p>
<p class="p3">Delete the existing "ChaosUGens.cpp" source file by clicking on it and pressing the delete key. Confirm the deletion in the dialog that is presented.</p>
<p class="p2"><br></p>
<p class="p13"><span class="s6"><img src="attachments/Writing_Unit_Generators/Pasted Graphic 11.png" alt="attachments/Writing_Unit_Generators/Pasted Graphic 11.png"></span></p>
<p class="p14"><br></p>
<p class="p2"><br></p>
<p class="p3">Use the "File-&gt;New File..." menu option to create a new source file.</p>
<p class="p2"><br></p>
<p class="p13"><span class="s6"><img src="attachments/Writing_Unit_Generators/Pasted Graphic 13.png" alt="attachments/Writing_Unit_Generators/Pasted Graphic 13.png"></span></p>
<p class="p2"><br></p>
<p class="p2"><br></p>
<p class="p3">Under the BSD section, select "C++ File", and click "Next".</p>
<p class="p2"><br></p>
<p class="p13"><span class="s6"><img src="attachments/Writing_Unit_Generators/Pasted Graphic 14.png" alt="attachments/Writing_Unit_Generators/Pasted Graphic 14.png"></span></p>
<p class="p14"><br></p>
<p class="p2"><br></p>
<p class="p3">Change the filename field to "MyUGens.cpp", uncheck the "Also create MyUGens.h" option, and check "MyUGens" as the only target. When all these options have been set, click "Finish".</p>
<p class="p2"><br></p>
<p class="p2"><br></p>
<p class="p13"><span class="s6"><img src="attachments/Writing_Unit_Generators/Pasted Graphic 15.png" alt="attachments/Writing_Unit_Generators/Pasted Graphic 15.png"></span></p>
<p class="p2"><br></p>
<p class="p3">Erase the default code, and copy the following into the MyUGens.cpp file:</p>
<p class="p3">____________________________________________________________________</p>
<p class="p8"><br></p>
<p class="p15"><span class="s1">#include </span>"SC_PlugIn.h"</p>
<p class="p8"><br></p>
<p class="p4">// InterfaceTable contains pointers to functions in the host (server).</p>
<p class="p5"><span class="s1">static </span>InterfaceTable<span class="s1"> *ft;</span></p>
<p class="p8"><br></p>
<p class="p4">// declare struct to hold unit generator state</p>
<p class="p7">struct <span class="s2">MySaw</span> : public <span class="s2">Unit</span></p>
<p class="p7">{</p>
<p class="p4"><span class="s1"><span class="Apple-tab-span">	</span>double mPhase; </span>// phase of the oscillator, from -1 to 1.</p>
<p class="p4"><span class="s1"><span class="Apple-tab-span">	</span>float mFreqMul; </span>// a constant for multiplying frequency</p>
<p class="p7">};</p>
<p class="p8"><br></p>
<p class="p4">// declare unit generator functions<span class="Apple-converted-space"> </span></p>
<p class="p7">extern <span class="s7">"C"</span></p>
<p class="p7">{</p>
<p class="p7"><span class="Apple-tab-span">	</span>void load(<span class="s2">InterfaceTable</span> *inTable);</p>
<p class="p7"><span class="Apple-tab-span">	</span>void <span class="s2">MySaw_next_a</span>(<span class="s2">MySaw</span> *unit, int inNumSamples);</p>
<p class="p7"><span class="Apple-tab-span">	</span>void <span class="s2">MySaw_next_k</span>(<span class="s2">MySaw</span> *unit, int inNumSamples);</p>
<p class="p7"><span class="Apple-tab-span">	</span>void <span class="s2">MySaw_Ctor</span>(<span class="s2">MySaw</span>* unit);</p>
<p class="p7">};</p>
<p class="p8"><br></p>
<p class="p4">//////////////////////////////////////////////////////////////////</p>
<p class="p8"><br></p>
<p class="p4">// Ctor is called to initialize the unit generator.<span class="Apple-converted-space"> </span></p>
<p class="p4">// It only executes once.</p>
<p class="p8"><br></p>
<p class="p4">// A Ctor usually does 3 things.</p>
<p class="p4">// 1. set the calculation function.</p>
<p class="p4">// 2. initialize the unit generator state variables.</p>
<p class="p4">// 3. calculate one sample of output.</p>
<p class="p5"><span class="s1">void </span>MySaw_Ctor<span class="s1">(</span>MySaw<span class="s1">* unit)</span></p>
<p class="p7">{</p>
<p class="p8"><br></p>
<p class="p4"><span class="s1"><span class="Apple-tab-span">	</span></span>// 1. set the calculation function.</p>
<p class="p7"><span class="Apple-tab-span">	</span>if (<span class="s2">INRATE</span>(0) == calc_FullRate) {</p>
<p class="p4"><span class="s1"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span></span>// if the frequency argument is audio rate<span class="Apple-converted-space"> </span></p>
<p class="p5"><span class="s1"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span></span>SETCALC<span class="s1">(</span>MySaw_next_a<span class="s1">);</span></p>
<p class="p7"><span class="Apple-tab-span">	</span>} else {</p>
<p class="p4"><span class="s1"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span></span>// if the frequency argument is control rate (or a scalar).</p>
<p class="p5"><span class="s1"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span></span>SETCALC<span class="s1">(</span>MySaw_next_k<span class="s1">);</span></p>
<p class="p7"><span class="Apple-tab-span">	</span>}</p>
<p class="p8"><br></p>
<p class="p4"><span class="s1"><span class="Apple-tab-span">	</span></span>// 2. initialize the unit generator state variables.</p>
<p class="p4"><span class="s1"><span class="Apple-tab-span">	</span></span>// initialize a constant for multiplying the frequency</p>
<p class="p7"><span class="Apple-tab-span">	</span>unit-&gt;mFreqMul = 2.0 * <span class="s2">SAMPLEDUR</span>;</p>
<p class="p4"><span class="s1"><span class="Apple-tab-span">	</span></span>// get initial phase of oscillator</p>
<p class="p7"><span class="Apple-tab-span">	</span>unit-&gt;mPhase = <span class="s2">IN0</span>(1);</p>
<p class="p8"><span class="Apple-tab-span">	</span></p>
<p class="p4"><span class="s1"><span class="Apple-tab-span">	</span></span>// 3. calculate one sample of output.</p>
<p class="p5"><span class="s1"><span class="Apple-tab-span">	</span></span>MySaw_next_k<span class="s1">(unit, 1);</span></p>
<p class="p7">}</p>
<p class="p8"><br></p>
<p class="p8"><br></p>
<p class="p4">//////////////////////////////////////////////////////////////////</p>
<p class="p8"><br></p>
<p class="p4">// The calculation function executes once per control period<span class="Apple-converted-space"> </span></p>
<p class="p4">// which is typically 64 samples.</p>
<p class="p8"><br></p>
<p class="p4">// calculation function for an audio rate frequency argument</p>
<p class="p7">void <span class="s2">MySaw_next_a</span>(<span class="s2">MySaw</span> *unit, int inNumSamples)</p>
<p class="p7">{</p>
<p class="p4"><span class="s1"><span class="Apple-tab-span">	</span></span>// get the pointer to the output buffer</p>
<p class="p7"><span class="Apple-tab-span">	</span>float *out = <span class="s2">OUT</span>(0);</p>
<p class="p8"><span class="Apple-tab-span">	</span></p>
<p class="p4"><span class="s1"><span class="Apple-tab-span">	</span></span>// get the pointer to the input buffer</p>
<p class="p7"><span class="Apple-tab-span">	</span>float *freq = <span class="s2">IN</span>(0);</p>
<p class="p8"><span class="Apple-tab-span">	</span></p>
<p class="p4"><span class="s1"><span class="Apple-tab-span">	</span></span>// get phase and freqmul constant from struct and store it in a<span class="Apple-converted-space"> </span></p>
<p class="p4"><span class="s1"><span class="Apple-tab-span">	</span></span>// local variable.</p>
<p class="p4"><span class="s1"><span class="Apple-tab-span">	</span></span>// The optimizer will cause them to be loaded it into a register.</p>
<p class="p7"><span class="Apple-tab-span">	</span>float freqmul = unit-&gt;mFreqMul;</p>
<p class="p7"><span class="Apple-tab-span">	</span>double phase = unit-&gt;mPhase;</p>
<p class="p8"><span class="Apple-tab-span">	</span></p>
<p class="p4"><span class="s1"><span class="Apple-tab-span">	</span></span>// perform a loop for the number of samples in the control period.</p>
<p class="p4"><span class="s1"><span class="Apple-tab-span">	</span></span>// If this unit is audio rate then inNumSamples will be 64 or whatever</p>
<p class="p4"><span class="s1"><span class="Apple-tab-span">	</span></span>// the block size is. If this unit is control rate then inNumSamples will</p>
<p class="p4"><span class="s1"><span class="Apple-tab-span">	</span></span>// be 1.</p>
<p class="p7"><span class="Apple-tab-span">	</span>for (int i=0; i &lt; inNumSamples; ++i)</p>
<p class="p7"><span class="Apple-tab-span">	</span>{</p>
<p class="p4"><span class="s1"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span></span>// out must be written last for in place operation</p>
<p class="p7"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>float z = phase;<span class="Apple-converted-space"> </span></p>
<p class="p7"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>phase += freq[i] * freqmul;</p>
<p class="p8"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span></p>
<p class="p4"><span class="s1"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span></span>// these if statements wrap the phase a +1 or -1.</p>
<p class="p7"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>if (phase &gt;= 1.f) phase -= 2.f;</p>
<p class="p7"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>else if (phase &lt;= -1.f) phase += 2.f;</p>
<p class="p8"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span></p>
<p class="p4"><span class="s1"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span></span>// write the output</p>
<p class="p7"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>out[i] = z;</p>
<p class="p7"><span class="Apple-tab-span">	</span>}</p>
<p class="p8"><br></p>
<p class="p4"><span class="s1"><span class="Apple-tab-span">	</span></span>// store the phase back to the struct</p>
<p class="p7"><span class="Apple-tab-span">	</span>unit-&gt;mPhase = phase;</p>
<p class="p7">}</p>
<p class="p8"><br></p>
<p class="p4">//////////////////////////////////////////////////////////////////</p>
<p class="p8"><br></p>
<p class="p4">// calculation function for a control rate frequency argument</p>
<p class="p7">void <span class="s2">MySaw_next_k</span>(<span class="s2">MySaw</span> *unit, int inNumSamples)</p>
<p class="p7">{</p>
<p class="p4"><span class="s1"><span class="Apple-tab-span">	</span></span>// get the pointer to the output buffer</p>
<p class="p7"><span class="Apple-tab-span">	</span>float *out = <span class="s2">OUT</span>(0);</p>
<p class="p8"><br></p>
<p class="p4"><span class="s1"><span class="Apple-tab-span">	</span></span>// freq is control rate, so calculate it once.</p>
<p class="p7"><span class="Apple-tab-span">	</span>float freq = <span class="s2">IN0</span>(0) * unit-&gt;mFreqMul;</p>
<p class="p8"><span class="Apple-tab-span">	</span></p>
<p class="p4"><span class="s1"><span class="Apple-tab-span">	</span></span>// get phase from struct and store it in a local variable.</p>
<p class="p4"><span class="s1"><span class="Apple-tab-span">	</span></span>// The optimizer will cause it to be loaded it into a register.</p>
<p class="p7"><span class="Apple-tab-span">	</span>double phase = unit-&gt;mPhase;</p>
<p class="p8"><span class="Apple-tab-span">	</span></p>
<p class="p4"><span class="s1"><span class="Apple-tab-span">	</span></span>// since the frequency is not changing then we can simplify the loops<span class="Apple-converted-space"> </span></p>
<p class="p4"><span class="s1"><span class="Apple-tab-span">	</span></span>// by separating the cases of positive or negative frequencies.<span class="Apple-converted-space"> </span></p>
<p class="p4"><span class="s1"><span class="Apple-tab-span">	</span></span>// This will make them run faster because there is less code inside the loop.</p>
<p class="p7"><span class="Apple-tab-span">	</span>if (freq &gt;= 0.f) {</p>
<p class="p4"><span class="s1"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span></span>// positive frequencies</p>
<p class="p7"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>for (int i=0; i &lt; inNumSamples; ++i)</p>
<p class="p7"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>{<span class="Apple-converted-space"> </span></p>
<p class="p7"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>out[i] = phase;</p>
<p class="p7"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>phase += freq;</p>
<p class="p7"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>if (phase &gt;= 1.f) phase -= 2.f;</p>
<p class="p7"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>}</p>
<p class="p7"><span class="Apple-tab-span">	</span>} else {</p>
<p class="p4"><span class="s1"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span></span>// negative frequencies</p>
<p class="p7"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>for (int i=0; i &lt; inNumSamples; ++i)</p>
<p class="p7"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>{<span class="Apple-converted-space"> </span></p>
<p class="p7"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>out[i] = phase;</p>
<p class="p7"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>phase += freq;</p>
<p class="p7"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>if (phase &lt;= -1.f) phase += 2.f;</p>
<p class="p7"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>}</p>
<p class="p7"><span class="Apple-tab-span">	</span>}</p>
<p class="p8"><br></p>
<p class="p4"><span class="s1"><span class="Apple-tab-span">	</span></span>// store the phase back to the struct</p>
<p class="p7"><span class="Apple-tab-span">	</span>unit-&gt;mPhase = phase;</p>
<p class="p7">}</p>
<p class="p8"><br></p>
<p class="p4">////////////////////////////////////////////////////////////////////</p>
<p class="p8"><br></p>
<p class="p4">// the load function is called by the host when the plug-in is loaded</p>
<p class="p7">void load(<span class="s2">InterfaceTable</span> *inTable)</p>
<p class="p7">{</p>
<p class="p7"><span class="Apple-tab-span">	</span>ft = inTable;</p>
<p class="p8"><br></p>
<p class="p5"><span class="s1"><span class="Apple-tab-span">	</span></span>DefineSimpleUnit<span class="s1">(</span>MySaw<span class="s1">);</span></p>
<p class="p7">}</p>
<p class="p8"><br></p>
<p class="p4">////////////////////////////////////////////////////////////////////</p>
<p class="p6"><br></p>
<p class="p3">____________________________________________________________________</p>
<p class="p6"><br></p>
<p class="p3">Drag the MyUGens target into the "All" aggregate target, and build the project using the "Build-&gt;Build" menu option.</p>
<p class="p6"><br></p>
<p class="p13"><span class="s6"><img src="attachments/Writing_Unit_Generators/Pasted Graphic 16.png" alt="attachments/Writing_Unit_Generators/Pasted Graphic 16.png"></span></p>
<p class="p14"><br></p>
<p class="p3">Now launch SuperCollider.app and create a file named MyUGens.sc in the class library. Add the following to this file:</p>
<p class="p3">____________________________________________________________________</p>
<p class="p8"><br></p>
<p class="p5">MySaw<span class="s1"> : </span>UGen<span class="s1"> {</span></p>
<p class="p7"><span class="Apple-tab-span">	</span>*ar { <span class="s2">arg</span> freq = 440.0, iphase = 0.0, mul = 1.0, add = 0.0;</p>
<p class="p7"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>^<span class="s2">this</span>.multiNew(<span class="s8">'audio'</span>, freq, iphase).madd(mul, add)</p>
<p class="p7"><span class="Apple-tab-span">	</span>}</p>
<p class="p7"><span class="Apple-tab-span">	</span>*kr { <span class="s2">arg</span> freq = 440.0, iphase = 0.0, mul = 1.0, add = 0.0;</p>
<p class="p7"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>^<span class="s2">this</span>.multiNew(<span class="s8">'control'</span>, freq, iphase).madd(mul, add)</p>
<p class="p7"><span class="Apple-tab-span">	</span>}</p>
<p class="p7">}</p>
<p class="p3">____________________________________________________________________</p>
<p class="p8"><br></p>
<p class="p3">The SuperCollider class for your UGen allows the SuperCollider application to be able to write a SynthDef file.</p>
<p class="p2"><br></p>
<p class="p3">The arguments to the MySaw UGen are freq and iphase.</p>
<p class="p3">The <span class="s9">multiNew</span> method handles multi channel expansion.</p>
<p class="p3">The <span class="s9">madd</span> method provides support for the mul and add arguments. It will create a MulAdd UGen if necessary. You could write the class without mul and add arguments, but providing them makes it more convenient for the user.</p>
<p class="p2"><br></p>
<p class="p4">// without mul and add.</p>
<p class="p5">MySaw<span class="s1"> : </span>UGen<span class="s1"> {</span></p>
<p class="p7"><span class="Apple-tab-span">	</span>*ar { <span class="s2">arg</span> freq = 440.0, iphase = 0.0;</p>
<p class="p7"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>^<span class="s2">this</span>.multiNew(<span class="s8">'audio'</span>, freq, iphase)</p>
<p class="p7"><span class="Apple-tab-span">	</span>}</p>
<p class="p7"><span class="Apple-tab-span">	</span>*kr { <span class="s2">arg</span> freq = 440.0, iphase = 0.0;</p>
<p class="p7"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>^<span class="s2">this</span>.multiNew(<span class="s8">'control'</span>, freq, iphase)</p>
<p class="p7"><span class="Apple-tab-span">	</span>}</p>
<p class="p7">}</p>
<p class="p2"><br></p>
<p class="p3">____________________________________________________________________</p>
<p class="p3">After a recompilation of the class library (Menu: Lang &gt; Complie Library), the UGen is</p>
<p class="p3">ready to be used.</p>
<p class="p8"><br></p>
<p class="p4">// test it:</p>
<p class="p8"><br></p>
<p class="p7">{ <span class="s2">MySaw</span>.ar(200,0,0.1) }.play</p>
<p class="p8"><br></p>
<p class="p2"><br></p>
<p class="p3">_________________________________________________________</p>
<p class="p3"><b>Workflow</b></p>
<p class="p2"><br></p>
<p class="p3">When changing the C-sourcecode, after each rebuilding the project, there is no need to restart SuperCollider or recompile the library (unless you have changed the class definition)</p>
<p class="p6"><br></p>
<p class="p4">// just reboot the server.</p>
<p class="p2"><br></p>
<p class="p16">s.reboot;</p>
<p class="p2"><br></p>
<p class="p3">Note that if you want to use the internal server (e.g. for scoping), you do need to restart</p>
<p class="p3">the SuperCollider application.</p>
<p class="p3">_________________________________________________________</p>
<p class="p8"><br></p>
<p class="p3"><b>Useful macros</b></p>
<p class="p2"><br></p>
<p class="p3">These are defined in SC_Unit.h.</p>
<p class="p8"><br></p>
<p class="p4">// These return float* pointers to input and output buffers.</p>
<p class="p7">#define <span class="s2">IN</span>(index)<span class="Apple-converted-space">  </span>(unit-&gt;mInBuf[index])</p>
<p class="p7">#define <span class="s2">OUT</span>(index) (unit-&gt;mOutBuf[index])</p>
<p class="p8"><br></p>
<p class="p6"><br></p>
<p class="p4">// These return a float value. Used for control rate inputs and outputs.</p>
<p class="p7">#define <span class="s2">IN0</span>(index)<span class="Apple-converted-space">  </span>(<span class="s2">IN</span>(index)[0])</p>
<p class="p7">#define <span class="s2">OUT0</span>(index) (<span class="s2">OUT</span>(index)[0])</p>
<p class="p8"><br></p>
<p class="p6"><br></p>
<p class="p4">// get the rate of the input.</p>
<p class="p7">#define <span class="s2">INRATE</span>(index) (unit-&gt;mInput[index]-&gt;mCalcRate)</p>
<p class="p8"><br></p>
<p class="p3">The possible rates are:</p>
<p class="p2"><br></p>
<p class="p7"><span class="Apple-tab-span">	</span>calc_ScalarRate</p>
<p class="p7"><span class="Apple-tab-span">	</span>calc_BufRate<span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>"control rate"</p>
<p class="p7"><span class="Apple-tab-span">	</span>calc_FullRate<span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>"audio rate"</p>
<p class="p8"><br></p>
<p class="p8"><br></p>
<p class="p4">// set the calculation function</p>
<p class="p7">#define <span class="s2">SETCALC</span>(func) (unit-&gt;mCalcFunc = (<span class="s2">UnitCalcFunc</span>)&amp;func)</p>
<p class="p8"><br></p>
<p class="p3">SETCALC must be called in the constructor. It may also be called from a calculation function to change to a different calculation function.</p>
<p class="p8"><br></p>
<p class="p6"><br></p>
<p class="p4">// calculate a slope for control rate interpolation to audio rate.</p>
<p class="p7">#define <span class="s2">CALCSLOPE</span>(next,prev) ((next - prev) * unit-&gt;mRate-&gt;mSlopeFactor)</p>
<p class="p8"><br></p>
<p class="p3">CALCSLOPE returns (next - prev) / blocksize which is useful for calculating slopes for linear interpolation.</p>
<p class="p8"><br></p>
<p class="p8"><br></p>
<p class="p7">#define <span class="s2">SAMPLERATE</span> (unit-&gt;mRate-&gt;mSampleRate)</p>
<p class="p8"><br></p>
<p class="p3">SAMPLERATE returns the sample rate for the unit generator. If it is audio rate then it will be the audio sample rate. If the ugen is control rate, then it will be the control rate. For example, if the ugen is control rate and the auio sample rate is 44100 and the block size is 64, then this will return 44100/64 or 689.0625.</p>
<p class="p8"><br></p>
<p class="p8"><br></p>
<p class="p7">#define <span class="s2">SAMPLEDUR</span> (unit-&gt;mRate-&gt;mSampleDur)</p>
<p class="p8"><br></p>
<p class="p3">SAMPLEDUR is simply the reciprocal of the sample rate. It is the seconds per sample.</p>
<p class="p8"><br></p>
<p class="p8"><br></p>
<p class="p7">#define <span class="s2">BUFLENGTH</span> (unit-&gt;mBufLength)</p>
<p class="p8"><br></p>
<p class="p3">BUFLENGTH is equal to the block size if the unit is audio rate and is equal to 1 if the unit is control rate.</p>
<p class="p8"><br></p>
<p class="p8"><br></p>
<p class="p7">#define <span class="s2">BUFRATE</span> (unit-&gt;mRate-&gt;mBufRate)</p>
<p class="p8"><br></p>
<p class="p3">BUFRATE always returns the control rate.</p>
<p class="p2"><br></p>
<p class="p8"><br></p>
<p class="p7">#define <span class="s2">BUFDUR</span> (unit-&gt;mRate-&gt;mBufDuration)</p>
<p class="p8"><br></p>
<p class="p3">BUFDUR is the reciprocal of the control rate.</p>
<p class="p8"><br></p>
<p class="p3">____________________________________________________________________</p>
<p class="p2"><br></p>
<p class="p3"><b>Pointer aliasing</b></p>
<p class="p8"><br></p>
<p class="p3">The server uses a "buffer coloring" algorithm to minimize use of buffers to optimize cache performance. This means that any of the output buffers may be the same as one of the input buffers. This allows for in-place operation which is very efficient. You must be careful however not to write any output sample before you have read all of the input samples. If you did, then the input will be overwritten with output.</p>
<p class="p8"><br></p>
<p class="p4">// This code is correct. It reads the freq input before writing to out.</p>
<p class="p7"><span class="Apple-tab-span">	</span>for (int i=0; i &lt; inNumSamples; ++i)</p>
<p class="p7"><span class="Apple-tab-span">	</span>{</p>
<p class="p7"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>float z = phase; <span class="s10">// store phase in z</span></p>
<p class="p7"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>phase += freq[i] * freqmul; <span class="s10">// read freq</span></p>
<p class="p4"><span class="s1"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>out[i] = z; </span>// write the output</p>
<p class="p8"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span></p>
<p class="p4"><span class="s1"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span></span>// these if statements wrap the phase a +1 or -1.</p>
<p class="p7"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>if (phase &gt;= 1.f) phase -= 2.f;</p>
<p class="p7"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>else if (phase &lt;= -1.f) phase += 2.f;</p>
<p class="p7"><span class="Apple-tab-span">	</span>}</p>
<p class="p8"><br></p>
<p class="p8"><br></p>
<p class="p4">// If out and freq are the same, then the code below will fail.</p>
<p class="p7"><span class="Apple-tab-span">	</span>for (int i=0; i &lt; inNumSamples; ++i)</p>
<p class="p7"><span class="Apple-tab-span">	</span>{</p>
<p class="p4"><span class="s1"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span></span>// write the output</p>
<p class="p7"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>out[i] = phase;<span class="Apple-converted-space"> </span></p>
<p class="p7"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>phase += freq[i] * freqmul;</p>
<p class="p8"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span></p>
<p class="p4"><span class="s1"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span></span>// these if statements wrap the phase a +1 or -1.</p>
<p class="p7"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>if (phase &gt;= 1.f) phase -= 2.f;</p>
<p class="p7"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>else if (phase &lt;= -1.f) phase += 2.f;</p>
<p class="p7"><span class="Apple-tab-span">	</span>}</p>
<p class="p8"><br></p>
<p class="p3">If your unit generator cannot be written efficiently when pointers are aliased, then you can tell the server this by using one of the following macros when definining it.</p>
<p class="p2"><br></p>
<p class="p7"><span class="Apple-tab-span">	</span>DefineSimpleCantAliasUnit(MyUGen);</p>
<p class="p8"><span class="Apple-tab-span">	</span></p>
<p class="p7"><span class="Apple-tab-span">	</span>DefineDtorCantAliasUnit(MyUGen);</p>
<p class="p2"><br></p>
<p class="p3">The server will then ensure that no output buffers are the same as any input buffers.</p>
<p class="p3">____________________________________________________________________</p>
<p class="p2"><br></p>
<p class="p1">A Unit Generator that needs a Dtor</p>
<p class="p17"><br></p>
<p class="p3">This is code for a simple fixed delay line.</p>
<p class="p2"><br></p>
<p class="p2"><br></p>
<p class="p15"><span class="s1">#include </span>"SC_PlugIn.h"</p>
<p class="p8"><br></p>
<p class="p4">// InterfaceTable contains pointers to functions in the host (server).</p>
<p class="p5"><span class="s1">static </span>InterfaceTable<span class="s1"> *ft;</span></p>
<p class="p8"><br></p>
<p class="p4">// declare struct to hold unit generator state</p>
<p class="p7">struct <span class="s2">MyDelay</span> : public <span class="s2">Unit</span></p>
<p class="p7">{</p>
<p class="p7"><span class="Apple-tab-span">	</span>uint32 mDelayLength;</p>
<p class="p7"><span class="Apple-tab-span">	</span>uint32 mPosition;</p>
<p class="p7"><span class="Apple-tab-span">	</span>float *mData; <span class="s10">// delay buffer</span></p>
<p class="p7">};</p>
<p class="p8"><br></p>
<p class="p4">// declare unit generator functions<span class="Apple-converted-space"> </span></p>
<p class="p7">extern <span class="s7">"C"</span></p>
<p class="p7">{</p>
<p class="p7"><span class="Apple-tab-span">	</span>void load(<span class="s2">InterfaceTable</span> *inTable);</p>
<p class="p7"><span class="Apple-tab-span">	</span>void <span class="s2">MyDelay_next_notfull</span>(<span class="s2">MyDelay</span> *unit, int inNumSamples);</p>
<p class="p7"><span class="Apple-tab-span">	</span>void <span class="s2">MyDelay_next_full</span>(<span class="s2">MyDelay</span> *unit, int inNumSamples);</p>
<p class="p5"><span class="s1"><span class="Apple-tab-span">	</span>void </span>MyDelay_Ctor<span class="s1">(</span>MyDelay<span class="s1">* unit);</span></p>
<p class="p5"><span class="s1"><span class="Apple-tab-span">	</span>void </span>MyDelay_Dtor<span class="s1">(</span>MyDelay<span class="s1">* unit);</span></p>
<p class="p7">};</p>
<p class="p8"><br></p>
<p class="p4">//////////////////////////////////////////////////////////////////</p>
<p class="p8"><br></p>
<p class="p4">// Ctor is called to initialize the unit generator.<span class="Apple-converted-space"> </span></p>
<p class="p4">// It only executes once.</p>
<p class="p8"><br></p>
<p class="p4">// A Ctor usually does 3 things.</p>
<p class="p4">// 1. set the calculation function.</p>
<p class="p4">// 2. initialize the unit generator state variables.</p>
<p class="p4">// 3. calculate one sample of output.</p>
<p class="p5"><span class="s1">void </span>MyDelay_Ctor<span class="s1">(</span>MyDelay<span class="s1">* unit)</span></p>
<p class="p7">{</p>
<p class="p8"><br></p>
<p class="p4"><span class="s1"><span class="Apple-tab-span">	</span></span>// 1. set the calculation function.</p>
<p class="p5"><span class="s1"><span class="Apple-tab-span">	</span></span>SETCALC<span class="s1">(</span>MyDelay_next_notfull<span class="s1">);</span></p>
<p class="p8"><br></p>
<p class="p4"><span class="s1"><span class="Apple-tab-span">	</span></span>// 2. initialize the unit generator state variables.</p>
<p class="p4"><span class="s1"><span class="Apple-tab-span">	</span></span>// get the delay length</p>
<p class="p7"><span class="Apple-tab-span">	</span>unit-&gt;mDelayLength = (uint32)(<span class="s2">IN0</span>(1) * <span class="s2">SAMPLERATE</span>);</p>
<p class="p8"><span class="Apple-tab-span">	</span></p>
<p class="p4"><span class="s1"><span class="Apple-tab-span">	</span></span>// allocate the buffer</p>
<p class="p7"><span class="Apple-tab-span">	</span>unit-&gt;mData = (float*)<span class="s2">RTAlloc</span>(unit-&gt;mWorld, unit-&gt;mDelayLength * sizeof(float));</p>
<p class="p4"><span class="s1"><span class="Apple-tab-span">	</span></span>// RTAlloc allocates out of the real time memory pool of the server<span class="Apple-converted-space"> </span></p>
<p class="p4"><span class="s1"><span class="Apple-tab-span">	</span></span>// which is finite. Note that this memory is not zeroed, so it may contain</p>
<p class="p4"><span class="Apple-tab-span">	</span>// garbage. Make sure to write before read.</p>
<p class="p4"><span class="Apple-tab-span">	</span>// The size of the real time memory pool is set using the</p>
<p class="p4"><span class="s1"><span class="Apple-tab-span">	</span></span>// -m command line argument of the server, or by ways of server.options.memSize</p>
<p class="p8"><span class="Apple-tab-span">	</span></p>
<p class="p4"><span class="s1"><span class="Apple-tab-span">	</span></span>// initialize the position</p>
<p class="p7"><span class="Apple-tab-span">	</span>unit-&gt;mPosition = 0;</p>
<p class="p8"><span class="Apple-tab-span">	</span></p>
<p class="p4"><span class="s1"><span class="Apple-tab-span">	</span></span>// 3. calculate one sample of output.</p>
<p class="p5"><span class="s1"><span class="Apple-tab-span">	</span></span>MyDelay_next_notfull<span class="s1">(unit, 1);</span></p>
<p class="p7">}</p>
<p class="p8"><br></p>
<p class="p4">//////////////////////////////////////////////////////////////////</p>
<p class="p8"><br></p>
<p class="p4">// Dtor is called to perform any clean up for the unit generator.<span class="Apple-converted-space"> </span></p>
<p class="p8"><br></p>
<p class="p5"><span class="s1">void </span>MyDelay_Dtor<span class="s1">(</span>MyDelay<span class="s1">* unit)</span></p>
<p class="p7">{</p>
<p class="p4"><span class="s1"><span class="Apple-tab-span">	</span></span>// free the buffer</p>
<p class="p7"><span class="Apple-tab-span">	</span><span class="s2">RTFree</span>(unit-&gt;mWorld, unit-&gt;mData);</p>
<p class="p7">}</p>
<p class="p8"><br></p>
<p class="p8"><br></p>
<p class="p4">//////////////////////////////////////////////////////////////////</p>
<p class="p8"><br></p>
<p class="p4">// The calculation function executes once per control period<span class="Apple-converted-space"> </span></p>
<p class="p4">// which is typically 64 samples.</p>
<p class="p8"><br></p>
<p class="p4">// calculation function when the buffer has not yet been filled</p>
<p class="p7">void <span class="s2">MyDelay_next_notfull</span>(<span class="s2">MyDelay</span> *unit, int inNumSamples)</p>
<p class="p7">{</p>
<p class="p4"><span class="s1"><span class="Apple-tab-span">	</span></span>// get the pointer to the output buffer</p>
<p class="p7"><span class="Apple-tab-span">	</span>float *out = <span class="s2">OUT</span>(0);</p>
<p class="p8"><span class="Apple-tab-span">	</span></p>
<p class="p4"><span class="s1"><span class="Apple-tab-span">	</span></span>// get the pointer to the input buffer</p>
<p class="p7"><span class="Apple-tab-span">	</span>float *in = <span class="s2">IN</span>(0);</p>
<p class="p8"><span class="Apple-tab-span">	</span></p>
<p class="p4"><span class="s1"><span class="Apple-tab-span">	</span></span>// get values from struct and store them in local variables.</p>
<p class="p4"><span class="s1"><span class="Apple-tab-span">	</span></span>// The optimizer will cause them to be loaded it into a register.</p>
<p class="p7"><span class="Apple-tab-span">	</span>float *data = unit-&gt;mData;</p>
<p class="p7"><span class="Apple-tab-span">	</span>uint32 length = unit-&gt;mDelayLength;</p>
<p class="p7"><span class="Apple-tab-span">	</span>uint32 position = unit-&gt;mPosition;</p>
<p class="p7"><span class="Apple-tab-span">	</span>bool wrapped = <span class="s2">false</span>;</p>
<p class="p8"><span class="Apple-tab-span">	</span></p>
<p class="p4"><span class="s1"><span class="Apple-tab-span">	</span></span>// perform a loop for the number of samples in the control period.</p>
<p class="p4"><span class="s1"><span class="Apple-tab-span">	</span></span>// If this unit is audio rate then inNumSamples will be 64 or whatever</p>
<p class="p4"><span class="s1"><span class="Apple-tab-span">	</span></span>// the block size is. If this unit is control rate then inNumSamples will</p>
<p class="p4"><span class="s1"><span class="Apple-tab-span">	</span></span>// be 1.</p>
<p class="p7"><span class="Apple-tab-span">	</span>for (int i=0; i &lt; inNumSamples; ++i)</p>
<p class="p7"><span class="Apple-tab-span">	</span>{</p>
<p class="p4"><span class="s1"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span></span>// get old value in delay line</p>
<p class="p7"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>float z = data[position];</p>
<p class="p4"><span class="s1"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span></span>// store new value in delay line</p>
<p class="p7"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>data[position] = in[i];</p>
<p class="p8"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span></p>
<p class="p4"><span class="s1"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span></span>// see if the position went to the end of the buffer<span class="Apple-converted-space"> </span></p>
<p class="p7"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>if (++position &gt;= length) {</p>
<p class="p4"><span class="s1"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>position = 0; </span>// go back to beginning</p>
<p class="p4"><span class="s1"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>wrapped = </span><span class="s2">true</span><span class="s1">; </span>// indicate we have wrapped.</p>
<p class="p8"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span></p>
<p class="p4"><span class="s1"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span></span>// change the calculation function</p>
<p class="p4"><span class="s1"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span></span>// next time, the MyDelay_next_full function will be called</p>
<p class="p5"><span class="s1"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span></span>SETCALC<span class="s1">(</span>MyDelay_next_full<span class="s1">);</span></p>
<p class="p7"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>}</p>
<p class="p4"><span class="s1"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span></span>// if we have not yet wrapped, then z is garbage from the uninitialized<span class="Apple-converted-space"> </span></p>
<p class="p4"><span class="s1"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span></span>// buffer, so output zero. If we have wrapped, then z is a good value.</p>
<p class="p7"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>out[i] = wrapped ? z : 0.f;</p>
<p class="p7"><span class="Apple-tab-span">	</span>}</p>
<p class="p8"><br></p>
<p class="p4"><span class="s1"><span class="Apple-tab-span">	</span></span>// store the position back to the struct</p>
<p class="p7"><span class="Apple-tab-span">	</span>unit-&gt;mPosition = position;</p>
<p class="p7">}</p>
<p class="p8"><br></p>
<p class="p4">//////////////////////////////////////////////////////////////////</p>
<p class="p8"><br></p>
<p class="p4">// calculation function when the buffer has been filled</p>
<p class="p7">void <span class="s2">MyDelay_next_full</span>(<span class="s2">MyDelay</span> *unit, int inNumSamples)</p>
<p class="p7">{</p>
<p class="p4"><span class="s1"><span class="Apple-tab-span">	</span></span>// get the pointer to the output buffer</p>
<p class="p7"><span class="Apple-tab-span">	</span>float *out = <span class="s2">OUT</span>(0);</p>
<p class="p8"><span class="Apple-tab-span">	</span></p>
<p class="p4"><span class="s1"><span class="Apple-tab-span">	</span></span>// get the pointer to the input buffer</p>
<p class="p7"><span class="Apple-tab-span">	</span>float *in = <span class="s2">IN</span>(0);</p>
<p class="p8"><span class="Apple-tab-span">	</span></p>
<p class="p4"><span class="s1"><span class="Apple-tab-span">	</span></span>// get values from struct and store them in local variables.</p>
<p class="p4"><span class="s1"><span class="Apple-tab-span">	</span></span>// The optimizer will cause them to be loaded it into a register.</p>
<p class="p7"><span class="Apple-tab-span">	</span>float *data = unit-&gt;mData;</p>
<p class="p7"><span class="Apple-tab-span">	</span>uint32 length = unit-&gt;mDelayLength;</p>
<p class="p7"><span class="Apple-tab-span">	</span>uint32 position = unit-&gt;mPosition;</p>
<p class="p8"><span class="Apple-tab-span">	</span></p>
<p class="p4"><span class="s1"><span class="Apple-tab-span">	</span></span>// perform a loop for the number of samples in the control period.</p>
<p class="p4"><span class="s1"><span class="Apple-tab-span">	</span></span>// If this unit is audio rate then inNumSamples will be 64 or whatever</p>
<p class="p4"><span class="s1"><span class="Apple-tab-span">	</span></span>// the block size is. If this unit is control rate then inNumSamples will</p>
<p class="p4"><span class="s1"><span class="Apple-tab-span">	</span></span>// be 1.</p>
<p class="p7"><span class="Apple-tab-span">	</span>for (int i=0; i &lt; inNumSamples; ++i)</p>
<p class="p7"><span class="Apple-tab-span">	</span>{</p>
<p class="p4"><span class="s1"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span></span>// get old value in delay line</p>
<p class="p7"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>float z = data[position];</p>
<p class="p4"><span class="s1"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span></span>// store new value in delay line</p>
<p class="p7"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>data[position] = in[i];</p>
<p class="p4"><span class="s1"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span></span>// see if the position went to the end of the buffer<span class="Apple-converted-space"> </span></p>
<p class="p7"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>if (++position &gt;= length) {</p>
<p class="p4"><span class="s1"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>position = 0; </span>// go back to beginning</p>
<p class="p7"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>}</p>
<p class="p7"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>out[i] = z;</p>
<p class="p7"><span class="Apple-tab-span">	</span>}</p>
<p class="p8"><br></p>
<p class="p4"><span class="s1"><span class="Apple-tab-span">	</span></span>// store the position back to the struct</p>
<p class="p7"><span class="Apple-tab-span">	</span>unit-&gt;mPosition = position;</p>
<p class="p7">}</p>
<p class="p8"><br></p>
<p class="p4">////////////////////////////////////////////////////////////////////</p>
<p class="p8"><br></p>
<p class="p4">// the load function is called by the host when the plug-in is loaded</p>
<p class="p7">void load(<span class="s2">InterfaceTable</span> *inTable)</p>
<p class="p7">{</p>
<p class="p7"><span class="Apple-tab-span">	</span>ft = inTable;</p>
<p class="p8"><br></p>
<p class="p5"><span class="s1"><span class="Apple-tab-span">	</span></span>DefineDtorUnit<span class="s1">(</span>MyDelay<span class="s1">);</span></p>
<p class="p7">}</p>
<p class="p8"><br></p>
<p class="p4">////////////////////////////////////////////////////////////////////</p>
<p class="p3">____________________________________________________________________</p>
<p class="p2"><br></p>
<p class="p8"><br></p>
<p class="p4">// In the MyUGens.sc file:</p>
<p class="p8"><br></p>
<p class="p5">MyDelay<span class="s1"> : </span>UGen<span class="s1"> {</span></p>
<p class="p7"><span class="Apple-tab-span">	</span>*ar { <span class="s2">arg</span> in, delaytime=0.4;</p>
<p class="p7"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>^<span class="s2">this</span>.multiNew(<span class="s8">'audio'</span>, in, delaytime)</p>
<p class="p7"><span class="Apple-tab-span">	</span>}</p>
<p class="p7"><span class="Apple-tab-span">	</span>*kr { <span class="s2">arg</span> in, delaytime=0.4;</p>
<p class="p7"><span class="Apple-tab-span">	</span><span class="Apple-tab-span">	</span>^<span class="s2">this</span>.multiNew(<span class="s8">'control'</span>, in, delaytime)</p>
<p class="p7"><span class="Apple-tab-span">	</span>}</p>
<p class="p7">}</p>
<p class="p3">____________________________________________________________________</p>
<p class="p8"><br></p>
<p class="p4">// test it</p>
<p class="p7">(</p>
<p class="p7">{</p>
<p class="p7"><span class="Apple-tab-span">	</span><span class="s2">var</span> z;</p>
<p class="p7"><span class="Apple-tab-span">	</span>z = <span class="s2">SinOsc</span>.ar * <span class="s2">Decay</span>.kr(<span class="s2">Impulse</span>.kr(1,0,0.2), 0.1);</p>
<p class="p7"><span class="Apple-tab-span">	</span>[z, <span class="s2">MyDelay</span>.ar(z, 0.3)]</p>
<p class="p7">}.play;</p>
<p class="p7">)</p>
<p class="p3">____________________________________________________________________</p>
<p class="p2"><br></p>
<p class="p2"><br></p>
<p class="p2"><br></p>
<p class="p3">TO DO:</p>
<p class="p3">UGens which access buffers.</p>
<p class="p3">UGens which use the built in random number generators.</p>
<p class="p2"><br></p>
<p class="p2"><br></p>
</body>
</html>
